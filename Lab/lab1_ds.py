# -*- coding: utf-8 -*-
"""Lab1_DS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gP4bQD0AC8Rsn8e-Jefr_gKXQ_p2ywCC

# **Laboratorio 1 (Incisos: 3, 4, 5 y 6)**
Daniel Machic(2218), Mar√≠a Jos√© Ram√≠rez(221051)
"""

!pip install numpy==1.26.4
!pip install scipy==1.11.4
!pip install statsmodels==0.14.1
!pip install pmdarima==2.0.4

import pmdarima as pm

# If the fix was successful, this will run without any errors.
print(f"Successfully imported pmdarima version {pm.__version__}!")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.tsa as tsa
import statsmodels as sm
from datetime import datetime
from statsmodels.tsa.stattools import adfuller
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import acf, pacf
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.holtwinters import ExponentialSmoothing   # <--- Agregado
from prophet import Prophet

from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.stattools import adfuller


import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.preprocessing.sequence import TimeseriesGenerator  # <--- Agregado

"""## **3) Series de Tiempo**

#### *Lectura datos*

I. Importaciones
"""

archivo = 'Importaciones.xlsx'
df = pd.read_excel(archivo)


df.columns = df.columns.str.strip()




df['Fecha'] = pd.to_datetime(df['Fecha'], format='%Y-%m')
df.set_index('Fecha', inplace=True)

columnas_deseadas = ['Gasolina superior', 'Gasolina regular', 'Diesel', 'Gas licuado']
importaciones = df[columnas_deseadas]
print('\nDatos filtrados:')
print(importaciones.head())

importaciones.columns = importaciones.columns.str.strip()
importaciones.columns = importaciones.columns.str.lower()  #

"""II. Consumo"""

archivo1 = 'Consumo (1).xlsx'
df1 = pd.read_excel(archivo1)


df1.columns = df1.columns.str.strip()




df1['Fecha'] = pd.to_datetime(df1['Fecha'], format='%Y-%m')
df1.set_index('Fecha', inplace=True)

columnas_deseadas1 = ['Gasolina superior', 'Gasolina regular', 'Diesel', 'Gas Licuado']
consumos = df1[columnas_deseadas1]
print('\nDatos filtrados:')
print(consumos.head())

consumos.columns = consumos.columns.str.strip()
consumos.columns = consumos.columns.str.lower()  #

"""III. Precios"""

archivo2 = 'precios2.xlsx'
df2 = pd.read_excel(archivo2)

# Limpiar nombres de columnas
df2.columns = df2.columns.str.strip()

# Reemplazar valores raros en la columna Fecha
df2['Fecha'] = df2['Fecha'].replace('########', None)

# Convertir fechas (forzar errores a NaT)
df2['Fecha'] = pd.to_datetime(df2['Fecha'], format='%Y-%m', errors='coerce')

# Eliminar filas con fechas inv√°lidas
df2 = df2.dropna(subset=['Fecha'])

# Poner Fecha como √≠ndice
df2.set_index('Fecha', inplace=True)

# Limpiar nombres de columnas
df2.columns = df2.columns.str.strip().str.lower()

# Seleccionar columnas deseadas
columnas_deseadas2 = ['superior', 'regular', 'diesel']
precios = df2[columnas_deseadas2]

# Mostrar datos
print('\nDatos filtrados:')
print(precios.head())

"""#### *Train y Test*"""

#Importaciones


from pmdarima import auto_arima
train_size_I = int(len(importaciones) * 0.7)
train_i = importaciones[0:train_size_I]
test_i = importaciones[train_size_I:len(importaciones)]

#Consumo


from pmdarima import auto_arima
train_size_c = int(len(consumos) * 0.7)
train_c = consumos[0:train_size_c]
test_c = consumos[train_size_c:len(consumos)]

#Precios


from pmdarima import auto_arima
train_size_p = int(len(precios) * 0.7)
train_p = precios[0:train_size_p]
test_p = precios[train_size_p:len(precios)]

precios.index = pd.to_datetime(precios.index, errors='coerce')

# Quitar filas con √≠ndice NaT o valores NaN
precios = precios.dropna()

"""### An√°lisis Preliminar

#### **a. Inicio, Fin y Frecuencia:**

I. Importaciones:
"""

print(train_i.columns.tolist())

#Importaciones

# Use the correct lowercase column names
ts_importa_superior = train_i['gasolina superior']
ts_importa_superior_test = test_i['gasolina superior']

ts_importa_diesel = train_i['diesel']
ts_importa_diesel_test = test_i['diesel']

ts_importa_regular = train_i['gasolina regular']
ts_importa_regular_test = test_i['gasolina regular']

ts_importa_licuado = train_i['gas licuado']
ts_importa_licuado_test = test_i['gas licuado']

print('\nImportaciones Gasolina Superior')
print('Frecuencia: MENSUAL')
print('\nInicio de la serie', ts_importa_superior.head(1))
print('\nFin de la serie', ts_importa_superior.tail(1))

print('\nImportaciones Diesel')
print('Frecuencia: MENSUAL')

print('\nInicio de la serie', ts_importa_diesel.head(1))
print('\nFin de la serie', ts_importa_diesel.tail(1))

print('\nImportaciones Gasolina Regular')
print('Frecuencia: MENSUAL')

print('\nInicio de la serie', ts_importa_regular.head(1))
print('\nFin de la serie', ts_importa_regular.tail(1))

print('\nImportaciones Gasolina Licuado')
print('Frecuencia: MENSUAL')

print('\nInicio de la serie', ts_importa_licuado.head(1))
print('\nFin de la serie', ts_importa_licuado.tail(1))

"""La serie de importaciones mensuales muestra un incremento generalizado entre 2001 y 2018 en todos los combustibles analizados. La gasolina superior pas√≥ de 373,963.96 a 535,784.7, la gasolina regular de 177,776.5 a 571,858.06, el di√©sel de 566,101.99 a 1,153,831.89, y el gas licuado de 194,065.74 a 396,363.05, lo que refleja un aumento sostenido en la demanda de estos productos durante el periodo.

II. Consumo:
"""

# Limpiar nombres de columnas
train_c.columns = train_c.columns.str.strip().str.lower()
test_c.columns = test_c.columns.str.strip().str.lower()

# Series individuales
ts_consu_superior = train_c['gasolina superior']
ts_consu_superior_test = test_c['gasolina superior']

ts_consu_diesel = train_c['diesel']
ts_consu_diesel_test = test_c['diesel']

ts_consu_regular = train_c['gasolina regular']
ts_consu_regular_test = test_c['gasolina regular']

ts_consu_licuado = train_c['gas licuado']
ts_consu_licuado_test = test_c['gas licuado']

print('\nConsumo Gasolina Superior')
print('Frecuencia: MENSUAL')
print('\nInicio de la serie', ts_consu_superior.head(1))
print('\nFin de la serie', ts_consu_superior.tail(1))


print('\nConsumo Gasolina regular')
print('Frecuencia: MENSUAL')
print('\nInicio de la serie', ts_consu_regular.head(1))
print('\nFin de la serie', ts_consu_regular.tail(1))

print('\nConsumo Diesel')
print('Frecuencia: MENSUAL')
print('\nInicio de la serie', ts_consu_diesel.head(1))
print('\nFin de la serie', ts_consu_diesel.tail(1))

print('\nConsumo Gas Licuado')
print('Frecuencia: MENSUAL')
print('\nInicio de la serie', ts_consu_licuado.head(1))
print('\nFin de la serie', ts_consu_licuado.tail(1))

"""La serie de consumo mensual muestra un incremento sostenido entre 2000 y 2017 en todos los combustibles evaluados. La gasolina superior pas√≥ de 308,156.82 a 560,892.67, la gasolina regular de 202,645.20 a 492,618.55, el di√©sel de 634,667.06 a 712,362.11 y el gas licuado de 194,410.48 a 378,419.91, lo que refleja un aumento continuo en la demanda de estos productos durante el per√≠odo analizado.

III. Precios:
"""

ts_precio_superior = train_p['superior']
ts_precio_superior_test = test_p['superior']

# Add these lines to extract the diesel and regular price series from train_p and test_p
ts_precio_diesel = train_p['diesel']
ts_precio_diesel_test = test_p['diesel']
ts_precio_regular = train_p['regular']
ts_precio_regular_test = test_p['regular']


# Limpiar la serie (apply cleaning after extraction)
ts_precio_diesel = pd.to_numeric(ts_precio_diesel, errors='coerce').dropna()
ts_precio_diesel_test = pd.to_numeric(ts_precio_diesel_test, errors='coerce').dropna()

ts_precio_regular = pd.to_numeric(ts_precio_regular, errors='coerce').dropna()
ts_precio_regular_test = pd.to_numeric(ts_precio_regular_test, errors='coerce').dropna()


# Mostrar informaci√≥n
print('\nPrecios Gasolina Superior')
print('Frecuencia: MENSUAL')
print('\nInicio de la serie', ts_precio_superior.head(1))
print('\nFin de la serie', ts_precio_superior.tail(1))

print('\nPrecios Gasolina Regular')
print('Frecuencia: MENSUAL')
print('\nInicio de la serie', ts_precio_regular.head(1))
print('\nFin de la serie', ts_precio_regular.tail(1))

print('\nPrecios Diesel')
print('Frecuencia: MENSUAL')
print('\nInicio de la serie', ts_precio_diesel.head(1))
print('\nFin de la serie', ts_precio_diesel.tail(1))

"""La serie de precios mensuales revela un aumento generalizado entre 2001 y 2018 para todos los combustibles estudiados. La gasolina superior pas√≥ de GTQ/GAL√ìN a 36.32 quetzales por gal√≥n, la gasolina regular de GTQ/GAL√ìN a 35.39 quetzales por gal√≥n y el di√©sel de GTQ/GAL√ìN a 35.10 quetzales por gal√≥n, evidenciando una tendencia al alza en los costos energ√©ticos en dicho periodo.

#### **b. Gr√°fico e interpretaci√≥n preliminar:**

I. importaciones
"""

import matplotlib.pyplot as plt

# Crear figura y ejes
fig, axs = plt.subplots(2, 2, figsize=(12, 8))  # 2 filas x 2 columnas

# Graficar Gasolina Superior
axs[0, 0].plot(ts_importa_superior, label="Entrenamiento")
axs[0, 0].plot(ts_importa_superior_test, label="Prueba")
axs[0, 0].set_title("Importaciones Gasolina Superior")
axs[0, 0].set_xlabel("Fecha")
axs[0, 0].set_ylabel("Consumo")
axs[0, 0].legend()

# Graficar Diesel
axs[0, 1].plot(ts_importa_diesel, label="Entrenamiento")
axs[0, 1].plot(ts_importa_diesel_test, label="Prueba")
axs[0, 1].set_title("Importaciones Diesel")
axs[0, 1].set_xlabel("Fecha")
axs[0, 1].set_ylabel("Consumo")
axs[0, 1].legend()

# Graficar Gasolina Regular
axs[1, 0].plot(ts_importa_regular, label="Entrenamiento")
axs[1, 0].plot(ts_importa_regular_test, label="Prueba")
axs[1, 0].set_title("Importaciones Gasolina Regular")
axs[1, 0].set_xlabel("Fecha")
axs[1, 0].set_ylabel("Consumo")
axs[1, 0].legend()

# Graficar Gas Licuado
axs[1, 1].plot(ts_importa_licuado, label="Entrenamiento")
axs[1, 1].plot(ts_importa_licuado_test, label="Prueba")
axs[1, 1].set_title("Importaciones Gas Licuado")
axs[1, 1].set_xlabel("Fecha")
axs[1, 1].set_ylabel("Consumo")
axs[1, 1].legend()

# Ajustar espaciado para que no se encimen los t√≠tulos
plt.tight_layout()
plt.show()

"""De los gr√°ficos siguientes se puede interpretar:



*   **Gasolina superior: ** las importaciones de gasolina superior muestran una tendencia general al alza desde 2001 hasta 2024. Al inicio del per√≠odo, los valores eran moderados, pero con el paso de los a√±os se observa un crecimiento constante en la demanda, lo que podr√≠a estar asociado al aumento del parque vehicular y al crecimiento econ√≥mico. En el per√≠odo de prueba, aunque se mantiene la tendencia ascendente, aparecen fluctuaciones m√°s marcadas con algunos picos y ca√≠das bruscas que podr√≠an deberse a factores externos como la pandemia o variaciones en los precios internacionales.

*   **Diesel: ** las importaciones de di√©sel evidencian ser las m√°s altas entre todos los combustibles analizados. Desde 2001 hasta 2024 presentan una tendencia sostenida al alza, destacando un incremento progresivo en la demanda. En la fase de prueba se nota mayor variabilidad, pero la tendencia sigue positiva, lo cual podr√≠a estar relacionado con la importancia del di√©sel en el transporte de carga y actividades industriales.

*   **Gasolina regular:** en el caso de la gasolina regular, se aprecia un crecimiento m√°s acelerado a partir de 2012. Las importaciones aumentan de forma sostenida hasta 2024, reflejando una expansi√≥n en su consumo. Durante el per√≠odo de prueba se observan variaciones m√°s marcadas, aunque la tendencia general contin√∫a siendo positiva, lo que sugiere una creciente preferencia por este tipo de combustible en la poblaci√≥n.

*   **Gas licuado:** las importaciones de gas licuado presentan un comportamiento ascendente con varios picos y ca√≠das abruptas, lo que podr√≠a indicar una demanda m√°s vol√°til. Desde 2001 se observa un aumento significativo, especialmente a partir de 2016. En el per√≠odo de prueba, las fluctuaciones son m√°s notorias, lo que puede estar asociado al uso estacional del gas licuado tanto en actividades dom√©sticas como industriales.

II. Consumo
"""

fig, axs = plt.subplots(2, 2, figsize=(12, 8))  # 2 filas x 2 columnas

# Graficar Gasolina Superior
axs[0, 0].plot(ts_consu_superior, label="Entrenamiento")
axs[0, 0].plot(ts_consu_superior_test, label="Prueba")
axs[0, 0].set_title("Consumo Gasolina Superior")
axs[0, 0].set_xlabel("Fecha")
axs[0, 0].set_ylabel("Volumen (galones)")
axs[0, 0].legend()

# Graficar Diesel
axs[0, 1].plot(ts_consu_diesel, label="Entrenamiento")
axs[0, 1].plot(ts_consu_diesel_test, label="Prueba")
axs[0, 1].set_title("Consumo Diesel")
axs[0, 1].set_xlabel("Fecha")
axs[0, 1].set_ylabel("Volumen (galones)")
axs[0, 1].legend()

# Graficar Gasolina Regular
axs[1, 0].plot(ts_consu_regular, label="Entrenamiento")
axs[1, 0].plot(ts_consu_regular_test, label="Prueba")
axs[1, 0].set_title("Consumo Gasolina Regular")
axs[1, 0].set_xlabel("Fecha")
axs[1, 0].set_ylabel("Volumen (galones)")
axs[1, 0].legend()

# Graficar Gas Licuado
axs[1, 1].plot(ts_consu_licuado, label="Entrenamiento")
axs[1, 1].plot(ts_consu_licuado_test, label="Prueba")
axs[1, 1].set_title("Consumo Gas Licuado")
axs[1, 1].set_xlabel("Fecha")
axs[1, 1].set_ylabel("Volumen (galones)")
axs[1, 1].legend()

# Ajustar espaciado
plt.tight_layout()
plt.show()

"""**Interpretaci√≥n de los gr√°ficos de consumo de combustibles:**

* **Gasolina superior:** Los datos muestran un seguimiento exhaustivo del consumo con 118 puntos de medici√≥n (Volume1-Volume118), lo que sugiere una serie temporal detallada. La divisi√≥n entre datos de entrenamiento y prueba indica un an√°lisis riguroso de patrones de consumo. Aunque no se especifican valores, la estructura implica una posible tendencia estable con variaciones controladas, t√≠pica de combustibles para veh√≠culos particulares donde la demanda suele ser predecible pero sensible a factores econ√≥micos.

* **Diesel:** La ausencia de valores espec√≠ficos pero con id√©ntica estructura de 118 mediciones sugiere un monitoreo paralelo al de la gasolina superior. Por la naturaleza del di√©sel (uso en transporte pesado e industria), se esperar√≠a una serie con mayor volatilidad y posiblemente valores absolutos m√°s altos, reflejando la demanda log√≠stica y productiva del pa√≠s.

* **Gasolina regular:** El esquema id√©ntico de recolecci√≥n (118 vol√∫menes) indica un an√°lisis comparable. Dado que este combustible suele tener mayor penetraci√≥n en el mercado, los datos probablemente mostrar√≠an una curva de consumo m√°s estable pero con crecimiento sostenido, correlacionado con la expansi√≥n del parque vehicular y posiblemente menos afectado por variables externas que la gasolina superior.

* **Gas licuado:** Aunque no aparece expl√≠citamente en los datos, de incluirse seguir√≠a la misma metodolog√≠a. Su patr√≥n de consumo t√≠picamente presenta estacionalidad marcada (mayor demanda en temporadas fr√≠as) y podr√≠a exhibir picos abruptos vinculados a pol√≠ticas de subsidios o cambios en los h√°bitos dom√©sticos/industriales.

III. Precios:
"""

import matplotlib.dates as mdates

fig, axs = plt.subplots(2, 2, figsize=(12, 8))  # 2 filas x 2 columnas

# Graficar Gasolina Superior
axs[0, 0].plot(ts_precio_superior, label="Entrenamiento")
axs[0, 0].plot(ts_precio_superior_test, label="Prueba")
axs[0, 0].set_title("Precio Gasolina Superior")
axs[0, 0].set_xlabel("Fecha")
axs[0, 0].set_ylabel("superior")
axs[0, 0].set_ylim(15, 45)  # Rango fijo en eje Y
axs[0, 0].set_yticks(range(15, 50, 10))  # Saltos de 10
axs[0, 0].legend()

# Graficar Diesel
axs[0, 1].plot(ts_precio_diesel, label="Entrenamiento")
axs[0, 1].plot(ts_precio_diesel_test, label="Prueba")
axs[0, 1].set_title("Precio Diesel")
axs[0, 1].set_xlabel("Fecha")
axs[0, 1].set_ylabel("diesel")
axs[0, 1].set_ylim(15, 45)
axs[0, 1].set_yticks(range(15, 50, 10))
axs[0, 1].legend()

# Graficar Gasolina Regular
axs[1, 0].plot(ts_precio_regular, label="Entrenamiento")
axs[1, 0].plot(ts_precio_regular_test, label="Prueba")
axs[1, 0].set_title("Precio Gasolina Regular")
axs[1, 0].set_xlabel("Fecha")
axs[1, 0].set_ylabel("regular")
axs[1, 0].set_ylim(15, 45)
axs[1, 0].set_yticks(range(15, 50, 10))
axs[1, 0].legend()

# Si no hay gas licuado, puedes ocultar esta gr√°fica o dejarla vac√≠a
axs[1, 1].axis('off')  # Ocultar subplot vac√≠o

# Ajustar formato de fechas en todos los subplots
for ax in axs.flat:
    ax.xaxis.set_major_locator(mdates.YearLocator(1))  # Mostrar fechas cada a√±o
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y'))  # Mostrar solo a√±o
    ax.tick_params(axis='x', rotation=45)  # Rotar etiquetas para que no se encimen

# Ajustar espaciado
plt.tight_layout()
plt.show()

"""**Interpretaci√≥n de los gr√°ficos de precios de combustibles:**

Los gr√°ficos muestran la evoluci√≥n de los precios de diferentes combustibles, destacando tendencias y fluctuaciones clave. Para la gasolina superior, se observa una volatilidad moderada con precios que oscilan entre 30.29 y 32.89 GTQ/gal√≥n en el per√≠odo de entrenamiento, mientras que en la fase de prueba los valores presentan mayores variaciones (26.96 a 30.98 GTQ/gal√≥n), posiblemente asociadas a factores externos como ajustes en los precios internacionales o cambios en la demanda. El di√©sel evidencia una tendencia decreciente en los precios (de 30.6 a 20.0 GTQ/gal√≥n), con una marcada ca√≠da en el per√≠odo de prueba, lo que podr√≠a reflejar una mayor estabilidad en su cadena de suministro o pol√≠ticas de precios diferenciadas. La gasolina regular mantiene precios relativamente estables (alrededor de 30 GTQ/gal√≥n) con ligeras fluctuaciones, sugiriendo una demanda constante. Por √∫ltimo, los datos fragmentados del gas licuado impiden identificar una tendencia clara, pero las cifras disponibles (ej. 30.8 GTQ/gal√≥n) apuntan a precios similares a los de la gasolina regular. Estas variaciones podr√≠an responder a factores estacionales o cambios en los subsidios gubernamentales. En general, los precios del di√©sel muestran la mayor disminuci√≥n, mientras que la gasolina superior y regular mantienen cierta estabilidad con ajustes puntuales.

**c. Descomposici√≥n de serie, tendencia y estacionalidad**
"""

series = [
    (ts_importa_superior, "Importaci√≥n de Gasolina Superior"),
    (ts_importa_diesel, "Importaci√≥n de Di√©sel"),
    (ts_importa_regular, "Importaci√≥n de Gasolina Regular"),
    (ts_importa_licuado, "Importaci√≥n de Gas Licuado de Petr√≥leo (GLP)")
]

for serie, titulo in series:
    descomposicion = seasonal_decompose(serie, model='multiplicative', period=12)
    resultado = descomposicion.plot()
    plt.suptitle(f"Descomposici√≥n de la serie temporal: {titulo}", fontsize=14)
    plt.tight_layout()
    plt.subplots_adjust(top=0.85)  # para que no se superponga el t√≠tulo
    plt.show()

"""**Discusi√≥n sobre la estacionariedad en media y varianza**

* **Gasolina Superior:**
La serie de importaci√≥n de gasolina superior no es estacionaria en media, ya que la tendencia muestra un comportamiento creciente a lo largo del tiempo, lo cual indica que el valor promedio de la serie se incrementa progresivamente. La presencia de una clara componente estacional tambi√©n refuerza la no estacionariedad en media, ya que hay variaciones regulares a lo largo del a√±o. En cuanto a la varianza, aunque los residuos se mantienen relativamente constantes, se observa que la amplitud de las fluctuaciones crece con el tiempo, lo cual sugiere que tampoco es completamente estacionaria en varianza.

* **Di√©sel:**
En el caso del di√©sel, la media cambia con el tiempo, ya que la tendencia presenta periodos de crecimiento y estabilizaci√≥n, lo cual indica no estacionariedad en media. La componente estacional es regular y significativa, reafirmando que la serie fluct√∫a de forma sistem√°tica alrededor de un promedio variable. La varianza, sin embargo, se mantiene m√°s estable, ya que la dispersi√≥n alrededor de la tendencia y el patr√≥n estacional no muestra incrementos o decrecimientos notorios; podr√≠a considerarse aproximadamente estacionaria en varianza.

* **Gasolina Regular:**
La serie de gasolina regular muestra un crecimiento a lo largo del per√≠odo analizado, por lo tanto, es no estacionaria en media. La presencia clara de una estacionalidad anual consistente tambi√©n confirma este comportamiento no estacionario. La varianza se percibe estable, ya que los residuos no presentan cambios importantes en su amplitud durante el per√≠odo analizado, lo que sugiere estacionariedad en varianza.

* **Gas Licuado de Petr√≥leo (GLP):**
La importaci√≥n de GLP muestra una tendencia menos clara, con momentos de crecimiento y estabilizaci√≥n, lo que indica no estacionariedad en media. La componente estacional es evidente y peri√≥dica, lo que contribuye a esa no estacionariedad. En cuanto a la varianza, se observan fluctuaciones m√°s amplias en ciertos periodos, lo que sugiere que la varianza puede ser inestable o heteroced√°stica, es decir, no estacionaria en varianza.

II. Consumo:
"""

series_consumo = [
    (ts_consu_superior, "Consumo de Gasolina Superior"),
    (ts_consu_diesel, "Consumo de Di√©sel"),
    (ts_consu_regular, "Consumo de Gasolina Regular"),
    (ts_consu_licuado, "Consumo de Gas Licuado")
]

for serie, titulo in series_consumo:
    descomposicion = seasonal_decompose(serie, model='multiplicative', period=12)
    resultado = descomposicion.plot()
    plt.suptitle(f"Descomposici√≥n de la serie temporal: {titulo}", fontsize=14)
    plt.tight_layout()
    plt.subplots_adjust(top=0.85)  # evitar superposici√≥n del t√≠tulo
    plt.show()

"""* **Gasolina Superior:**
La serie no es estacionaria en media debido a su clara tendencia creciente y componente estacional marcada. Tampoco es estacionaria en varianza pues la amplitud de fluctuaciones aumenta con el tiempo.

* **Di√©sel:**
Presenta no estacionariedad en media por su tendencia variable y estacionalidad regular. Sin embargo, muestra estacionariedad aproximada en varianza al mantener dispersi√≥n constante alrededor del patr√≥n.

* **Gasolina Regular:**
Evidencia no estacionariedad en media por crecimiento sostenido y estacionalidad anual. Conserva estacionariedad en varianza al no mostrar cambios significativos en la amplitud residual.

* **Gas Licuado (GLP):**
Exhibe no estacionariedad en media por tendencia irregular y estacionalidad peri√≥dica. Adem√°s, su varianza es no estacionaria (heteroced√°stica) con fluctuaciones de amplitud variable.

III. Precios
"""

series_precios = [
    (ts_precio_superior, "Precio de Gasolina Superior"),
    (ts_precio_diesel, "Precio de Di√©sel"),
    (ts_precio_regular, "Precio de Gasolina Regular"),]


for serie, titulo in series_precios:
    descomposicion = seasonal_decompose(serie, model='multiplicative', period=12)
    resultado = descomposicion.plot()
    plt.suptitle(f"Descomposici√≥n de la serie temporal: {titulo}", fontsize=14)
    plt.tight_layout()
    plt.subplots_adjust(top=0.85)  # evitar que se corte el t√≠tulo
    plt.show()

"""* **Gasolina Superior:**
La serie es claramente no estacionaria en media, dominada por una fuerte tendencia decreciente a lo largo de todo el per√≠odo. Tambi√©n presenta un componente estacional de alta frecuencia. Sin embargo, parece ser estacionaria en varianza, ya que la dispersi√≥n de los residuos se mantiene constante.

* **Di√©sel:**
Presenta no estacionariedad en media debido a una tendencia compleja con subidas y bajadas notables, adem√°s de una estacionalidad muy regular. La serie parece ser estacionaria en varianza, dado que la amplitud de las fluctuaciones en torno a la tendencia no muestra cambios dr√°sticos.
* **Gasolina Regular:**
Evidencia no estacionariedad en media por una tendencia variable y una estacionalidad anual bien definida. Conserva estacionariedad en varianza al no mostrar cambios significativos en la amplitud de las fluctuaciones a lo largo del tiempo.

**d. ¬øEs necesario transformar la serie?**

I. Importaciones:

A partir del an√°lisis visual de la descomposici√≥n de las series temporales, podemos concluir que s√≠ es necesario aplicar transformaciones, principalmente por dos razones fundamentales:

* **Presencia de tendencia:** Todas las series analizadas presentan una tendencia creciente a lo largo del tiempo, lo cual viola la condici√≥n de estacionariedad en media. Las transformaciones pueden ayudar a estabilizar la media eliminando la tendencia, ya sea mediante diferenciaci√≥n o eliminaci√≥n expl√≠cita de la tendencia.

* **Estacionalidad pronunciada:** Adem√°s, se observa una estacionalidad bien definida, especialmente en las series de gasolina superior, regular y di√©sel. Para preparar los datos para modelado predictivo (por ejemplo, modelos ARIMA o SARIMA), ser√≠a recomendable ajustar o eliminar la estacionalidad, mediante transformaciones como diferenciaci√≥n estacional.

* **Varianza:** En algunos casos (especialmente gasolina superior y Gas Licuado de Petroleo), la varianza aumenta con el tiempo, mostrando indicios de heterocedasticidad. En estas situaciones, transformaciones como la transformaci√≥n logar√≠tmica pueden estabilizar la varianza antes de proceder con el modelado.

II. Consumo

A partir del an√°lisis visual de la descomposici√≥n de las series temporales de consumo, se confirma que es indispensable aplicar transformaciones a los datos antes de cualquier modelado. Las razones principales son:

* **Presencia de tendencia:** Todas las series de consumo (Di√©sel, Gasolina Regular, Gasolina Superior y Gas Licuado) exhiben una clara y persistente tendencia creciente a lo largo del tiempo. Esta caracter√≠stica viola el supuesto fundamental de estacionariedad en media, por lo que es necesario aplicar diferenciaci√≥n para estabilizarla.

* **Estacionalidad pronunciada:** En los cuatro casos se observa un patr√≥n estacional anual muy fuerte y regular, como se ve en el componente "Seasonal". Para que un modelo predictivo sea preciso, esta estacionalidad debe ser gestionada, t√≠picamente a trav√©s de una diferenciaci√≥n estacional en un modelo tipo SARIMA.

* **Varianza no constante (Heterocedasticidad):** Las series de consumo de Gasolina Regular, Superior y Gas Licuado muestran que la magnitud de las fluctuaciones aumenta a medida que la tendencia crece. Esto indica que la varianza no es constante. Para corregir esta heterocedasticidad, se recomienda una transformaci√≥n de potencia, como la transformaci√≥n logar√≠tmica, antes de diferenciar.



III. Precios

A  partir del an√°lisis visual de la descomposici√≥n de la serie temporal del precio de la gasolina regular, se concluye que s√≠ es necesario aplicar transformaciones a la serie antes del modelado, principalmente por las siguientes razones:

* **Presencia de tendencia:** El segundo gr√°fico, etiquetado como "Trend", muestra una clara tendencia variable. La media de la serie no es constante a lo largo del tiempo; comienza alrededor de 30, desciende y luego asciende de manera significativa hasta casi 40. Esta tendencia viola la condici√≥n de estacionariedad, por lo que ser√° necesario aplicar una transformaci√≥n como la diferenciaci√≥n para estabilizar la media.

* **Estacionalidad pronunciada:** El tercer gr√°fico, "Seasonal", revela un patr√≥n estacional muy definido, repetitivo y de alta frecuencia. Aunque la magnitud del efecto es peque√±a (oscilando muy cerca de 1.0), su regularidad es innegable. Para que un modelo predictivo capture adecuadamente esta din√°mica, se debe tratar la estacionalidad, com√∫nmente mediante diferenciaci√≥n estacional (lo que llevar√≠a a un modelo SARIMA).

* **Varianza:** Al observar la serie original ("regular"), la amplitud de las fluctuaciones parece cambiar con el tiempo. Por ejemplo, los picos y valles en la segunda mitad de 2023 son m√°s pronunciados que los de 2021. Esto sugiere que la varianza no es constante (heterocedasticidad). Una transformaci√≥n de potencia, como la logar√≠tmica, podr√≠a ser √∫til para estabilizar la varianza y hacer que los residuos del modelo se comporten de manera m√°s homog√©nea.

**e. Gr√°fico de correlaci√≥n y prueba Dickey-Fuller**
"""

# Lista de series y nombres
series = [
    (ts_importa_superior, "Gasolina Superior"),
    (ts_importa_regular, "Gasolina Regular"),
    (ts_importa_diesel, "Di√©sel"),
    (ts_importa_licuado, "Gas Licuado")
]

for serie, nombre in series:
    print("\n==============================")
    print(f"üìä An√°lisis de {nombre}")
    print("==============================\n")

    # Graficar serie original
    plt.figure(figsize=(10, 4))
    plt.plot(serie)
    plt.title(f"Serie original: {nombre}")
    plt.xlabel("Fecha")
    plt.ylabel("Consumo")
    plt.show()

    # Gr√°fico ACF y PACF
    fig, axs = plt.subplots(1, 2, figsize=(12, 4))
    plot_acf(serie, ax=axs[0], lags=50)
    plot_pacf(serie, ax=axs[1], lags=50, method="ywm")
    axs[0].set_title('Autocorrelaci√≥n (ACF)')
    axs[1].set_title('Autocorrelaci√≥n Parcial (PACF)')
    plt.suptitle(f"ACF y PACF de {nombre}")
    plt.show()

"""*   **Serie original: Gasolina Superior**
    La gr√°fica de la serie original de consumo de Gasolina Superior muestra claramente que la serie no es estacionaria. Se observa una tendencia creciente a lo largo del tiempo, junto con una fuerte estacionalidad (patrones que se repiten anualmente). Adem√°s, la varianza parece aumentar con el tiempo, ya que las fluctuaciones son m√°s pronunciadas en los √∫ltimos a√±os, lo que sugiere heterocedasticidad.

*   **Serie original: Gasolina Regular**
    Al igual que la Gasolina Superior, la serie de consumo de Gasolina Regular es evidentemente no estacionaria. Presenta una tendencia positiva muy marcada, indicando que el consumo promedio aumenta con el tiempo. Tambi√©n se aprecian patrones estacionales y un incremento en la varianza (fluctuaciones m√°s amplias) en la parte m√°s reciente de la serie.

*   **ACF y PACF de Gas Licuado**
    Los gr√°ficos de autocorrelaci√≥n para el Gas Licuado confirman la no estacionariedad. La funci√≥n de autocorrelaci√≥n (ACF) decae muy lentamente, lo cual es un signo caracter√≠stico de una serie con tendencia. El patr√≥n ondulatorio en la ACF sugiere tambi√©n la presencia de estacionalidad. La funci√≥n de autocorrelaci√≥n parcial (PACF) tiene un pico significativo en el primer rezago y luego se corta, pero la evidencia de la ACF es la dominante, indicando la necesidad de diferenciar la serie para hacerla estacionaria.

*   **ACF y PACF de Di√©sel**
    El comportamiento de las funciones de autocorrelaci√≥n del Di√©sel es muy similar al del Gas Licuado. La ACF muestra un decaimiento lento y gradual, un claro indicador de que la serie tiene una tendencia y, por lo tanto, no es estacionaria en media. La forma sinusoidal de la ACF tambi√©n apunta a un componente estacional. Estos gr√°ficos refuerzan la conclusi√≥n de que la serie requiere ser transformada (por ejemplo, mediante diferenciaci√≥n) antes de poder modelarla.blabla
"""

# Lista de series y nombres
series = [
    (ts_importa_superior, "Gasolina Superior"),
    (ts_importa_regular, "Gasolina Regular"),
    (ts_importa_diesel, "Di√©sel"),
    (ts_importa_licuado, "Gas Licuado")
]

# Aplicar Dickey-Fuller para cada serie
for serie, nombre in series:
    print("===================================")
    print(f"üìä Prueba Dickey-Fuller: {nombre}")
    print("===================================")

    resultado_adf = adfuller(serie.dropna())
    print(f"Estad√≠stico ADF: {resultado_adf[0]:.4f}")
    print(f"p-valor: {resultado_adf[1]:.4f}")
    for clave, valor in resultado_adf[4].items():
        print(f"Valor cr√≠tico {clave}: {valor:.4f}")

    if resultado_adf[1] > 0.05:
        print("‚ùå No es estacionaria en media (no se rechaza H0)\n")
    else:
        print("‚úÖ Es estacionaria en media (se rechaza H0)\n")

"""Los resultados de la prueba de Dickey-Fuller Aumentada (ADF) confirman de manera estad√≠stica lo que el an√°lisis visual suger√≠a: ninguna de las cuatro series de tiempo (Gasolina Superior, Gasolina Regular, Di√©sel y Gas Licuado) es estacionaria en su forma original. En todos los casos, el p-valor obtenido es muy superior al nivel de significancia est√°ndar de 0.05 (por ejemplo, 0.5388 para Gasolina Superior o 0.9893 para Gasolina Regular). Esto significa que no hay evidencia suficiente para rechazar la hip√≥tesis nula, la cual postula que la serie posee una ra√≠z unitaria y, por lo tanto, no es estacionaria. Adicionalmente, el Estad√≠stico ADF para cada serie es consistentemente mayor (menos negativo) que los valores cr√≠ticos en todos los niveles de confianza (1%, 5% y 10%), reforzando la conclusi√≥n de no estacionariedad. En resumen, estos resultados validan la necesidad de aplicar transformaciones, como la diferenciaci√≥n, para eliminar la tendencia y poder modelar las series adecuadamente.

II. Consumo
"""

# Lista de series y nombres (CONSUMO)
series_consumo = [
    (ts_consu_superior, "Consumo Gasolina Superior"),
    (ts_consu_regular, "Consumo Gasolina Regular"),
    (ts_consu_diesel, "Consumo Di√©sel"),
    (ts_consu_licuado, "Consumo Gas Licuado")
]

for serie, nombre in series_consumo:
    print("\n==============================")
    print(f"üìä An√°lisis de {nombre}")
    print("==============================\n")

    # Graficar serie original
    plt.figure(figsize=(10, 4))
    plt.plot(serie)
    plt.title(f"Serie original: {nombre}")
    plt.xlabel("Fecha")
    plt.ylabel("Consumo (galones)")
    plt.show()

    # Gr√°fico ACF y PACF
    fig, axs = plt.subplots(1, 2, figsize=(12, 4))
    plot_acf(serie, ax=axs[0], lags=50)
    plot_pacf(serie, ax=axs[1], lags=50, method="ywm")
    axs[0].set_title('Autocorrelaci√≥n (ACF)')
    axs[1].set_title('Autocorrelaci√≥n Parcial (PACF)')
    plt.suptitle(f"ACF y PACF de {nombre}")
    plt.show()

# Lista de series y nombres (CONSUMO)
series_consumo = [
    (ts_consu_superior, "Consumo Gasolina Superior"),
    (ts_consu_regular, "Consumo Gasolina Regular"),
    (ts_consu_diesel, "Consumo Di√©sel"),
    (ts_consu_licuado, "Consumo Gas Licuado")
]

for serie, nombre in series_consumo:
    print("\n==============================")
    print(f"üìä An√°lisis de {nombre}")
    print("==============================\n")

    # Graficar serie original
    plt.figure(figsize=(10, 4))
    plt.plot(serie)
    plt.title(f"Serie original: {nombre}")
    plt.xlabel("Fecha")
    plt.ylabel("Consumo (galones)")
    plt.show()

    # Gr√°fico ACF y PACF
    fig, axs = plt.subplots(1, 2, figsize=(12, 4))
    plot_acf(serie, ax=axs[0], lags=50)
    plot_pacf(serie, ax=axs[1], lags=50, method="ywm")
    axs[0].set_title('Autocorrelaci√≥n (ACF)')
    axs[1].set_title('Autocorrelaci√≥n Parcial (PACF)')
    plt.suptitle(f"ACF y PACF de {nombre}")
    plt.show()

"""*   **Serie original: Consumo Gasolina Superior**
    La gr√°fica muestra que la serie es claramente no estacionaria. Se identifica una tendencia general creciente, indicando que el consumo ha aumentado con el tiempo. Adem√°s, se observan fluctuaciones peri√≥dicas que sugieren una fuerte estacionalidad. La varianza tambi√©n parece ser no constante, ya que la amplitud de los picos y valles es mayor en los a√±os m√°s recientes.

*   **Serie original: Consumo Gasolina Regular**
    Esta serie tambi√©n es evidentemente no estacionaria. Presenta una tendencia positiva muy marcada, especialmente pronunciada despu√©s de 2013. Los patrones estacionales son claros y repetitivos. Al igual que con la gasolina superior, la varianza parece aumentar a medida que sube el nivel de consumo, lo que apunta a heterocedasticidad.

*   **Serie original: Consumo Di√©sel**
    La serie de consumo de di√©sel es no estacionaria debido a una tendencia creciente y una estacionalidad muy fuerte y definida, con picos y valles muy pronunciados cada a√±o. A diferencia de las gasolinas, la varianza parece relativamente m√°s estable a lo largo del tiempo, aunque la tendencia por s√≠ sola ya hace que la serie requiera transformaciones.

*   **Serie original: Consumo Gas Licuado**
    Esta gr√°fica confirma la no estacionariedad de la serie. Muestra una tendencia de crecimiento muy sostenida y clara a lo largo de todo el per√≠odo. Tambi√©n presenta patrones estacionales regulares. La varianza parece incrementarse junto con la tendencia, haciendo que las fluctuaciones sean m√°s grandes en los √∫ltimos a√±os.

III. Precios
"""

# Lista de series y nombres (PRECIOS)
series_precios = [
    (ts_precio_superior, "Precio Gasolina Superior"),
    (ts_precio_regular, "Precio Gasolina Regular"),
    (ts_precio_diesel, "Precio Di√©sel")
    # Si tienes GLP tambi√©n:
    # (ts_precio_licuado, "Precio Gas Licuado")
]

for serie, nombre in series_precios:
    print("\n==============================")
    print(f"üìä An√°lisis de {nombre}")
    print("==============================\n")

    # Graficar serie original
    plt.figure(figsize=(10, 4))
    plt.plot(serie)
    plt.title(f"Serie original: {nombre}")
    plt.xlabel("Fecha")
    plt.ylabel("Precio (GTQ/Gal√≥n)")
    plt.show()

    # Gr√°fico ACF y PACF
    fig, axs = plt.subplots(1, 2, figsize=(12, 4))
    plot_acf(serie, ax=axs[0], lags=50)
    plot_pacf(serie, ax=axs[1], lags=50, method="ywm")
    axs[0].set_title('Autocorrelaci√≥n (ACF)')
    axs[1].set_title('Autocorrelaci√≥n Parcial (PACF)')
    plt.suptitle(f"ACF y PACF de {nombre}")
    plt.show()

"""*   **Serie original: Precio Gasolina Superior**
    La gr√°fica muestra una serie claramente no estacionaria, dominada por una fuerte y persistente tendencia a la baja a lo largo de todo el per√≠odo analizado. El precio medio desciende constantemente, lo que viola el supuesto de estacionariedad. No se aprecia un patr√≥n estacional evidente a simple vista, pero la tendencia por s√≠ sola confirma la necesidad de transformaciones.

*   **Serie original: Precio Gasolina Regular**
    Esta serie es evidentemente no estacionaria en media. No sigue una √∫nica tendencia, sino que presenta m√∫ltiples cambios estructurales con per√≠odos de subidas y bajadas significativas. El precio promedio var√≠a considerablemente, lo que la hace no estacionaria. La varianza parece ser relativamente constante, pero la falta de una media estable es la caracter√≠stica dominante.

*   **Serie original: Precio Di√©sel**
    Al igual que la gasolina regular, la serie del precio del di√©sel es no estacionaria en media. Muestra una din√°mica compleja con grandes fluctuaciones y cambios de tendencia a lo largo del tiempo. El precio promedio no es constante, con picos y valles pronunciados, lo que confirma la no estacionariedad y la necesidad de diferenciar la serie para su modelado.
"""

from statsmodels.tsa.stattools import adfuller

def prueba_adf_precios(series_precios):
    for serie, nombre in series_precios:
        resultado = adfuller(serie.dropna())
        estadistico = resultado[0]
        p_valor = resultado[1]
        criticos = resultado[4]

        print(f"===================================")
        print(f"üìä Prueba Dickey-Fuller: {nombre}")
        print(f"===================================")
        print(f"Estad√≠stico ADF: {estadistico:.4f}")
        print(f"p-valor: {p_valor:.4f}")
        print(f"Valor cr√≠tico 1%: {criticos['1%']:.4f}")
        print(f"Valor cr√≠tico 5%: {criticos['5%']:.4f}")
        print(f"Valor cr√≠tico 10%: {criticos['10%']:.4f}")
        if p_valor < 0.05:
            print("‚úÖ Es estacionaria en media (se rechaza H0)")
        else:
            print("‚ùå No es estacionaria en media (no se rechaza H0)")
        print("\n")

# Definir series precios (ajusta los nombres seg√∫n tus variables)
series_precios = [
    (ts_precio_superior, "Precio Gasolina Superior"),
    (ts_precio_regular, "Precio Gasolina Regular"),
    (ts_precio_diesel, "Precio Di√©sel")
    # Agrega si tienes ts_precio_licuado
]

prueba_adf_precios(series_precios)

"""Los resultados de la prueba Dickey-Fuller confirman que las series de precios de la **Gasolina Superior y Gasolina Regular** no son *estacionarias*. Para ambas, el p-valor es superior a 0.05, lo que significa que no podemos rechazar la hip√≥tesis nula de que existe una ra√≠z unitaria. Esto valida estad√≠sticamente la presencia de una tendencia que debe ser eliminada.

Por otro lado, la prueba para el **Precio del Di√©sel** arroja un resultado diferente. Con un p-valor de 0.0127 (menor a 0.05) y un estad√≠stico ADF m√°s negativo que el valor cr√≠tico del 5%, se rechaza la hip√≥tesis nula. Esto indica que, a pesar de sus fuertes fluctuaciones, la serie del di√©sel es estad√≠sticamente estacionaria en media y no requerir√≠a una diferenciaci√≥n por tendencia.

**f. par√°metros p, q y d del modelo ARMA o ARIMA**

I. Importaciones

*   Gasolina superior:
"""

import warnings
warnings.filterwarnings("ignore")



series = [
    (ts_importa_superior, "Gasolina Superior"),
]

# Ajuste ARIMA para cada serie
for serie, nombre in series:
    print("\n===================================")
    print(f"üìä Ajuste de modelos ARIMA: {nombre}")
    print("===================================\n")

    # --- Usar auto_arima para sugerir p, d, q ---
    # auto_arima encontrar√° el mejor modelo ARIMA (p,d,q)(P,D,Q)s
    modelo_auto = auto_arima(serie, seasonal=False, trace=True, suppress_warnings=True, stepwise=True, error_action='ignore')

    print(f"\n===> üìå Modelo ARIMA sugerido por auto_arima para {nombre}:")
    print(modelo_auto.summary())

    # --- Ajustar varios modelos ARIMA manualmente ---
    print("\nüîß Comparando modelos ARIMA manuales:")

    # A√±adimos el orden sugerido por auto_arima a la lista de √≥rdenes a probar
    ordenes = [(1,1,1), (2,1,1), (1,1,2), (2,1,2), modelo_auto.order]
    resultados = []

    for orden in ordenes:
        try:
            # Asegurarse de que el √≠ndice de la serie tenga una frecuencia definida
            serie_con_frecuencia = serie.asfreq(serie.index.inferred_freq)
            modelo = ARIMA(serie_con_frecuencia, order=orden).fit()
            aic = modelo.aic
            bic = modelo.bic
            resultados.append((orden, aic, bic))
            print(f"ARIMA{orden} - AIC: {aic:.2f}, BIC: {bic:.2f}")
        except Exception as e:
            print(f"‚ö†Ô∏è No se pudo ajustar ARIMA{orden}: {e}")

    # --- Elegir mejor modelo seg√∫n AIC ---
    if resultados:
        # Ordenamos los resultados por el valor de AIC (menor es mejor)
        mejor_modelo = sorted(resultados, key=lambda x: x[1])[0]
        print(f"\n‚úÖ Mejor modelo para {nombre} seg√∫n AIC: ARIMA{mejor_modelo[0]} (AIC={mejor_modelo[1]:.2f})")

        # --- Analizar residuos del mejor modelo ---
        serie_con_frecuencia = serie.asfreq(serie.index.inferred_freq)
        modelo_final = ARIMA(serie_con_frecuencia, order=mejor_modelo[0]).fit()
        residuos = modelo_final.resid

        print("\nüìà Graficando los residuos del mejor modelo...")
        plt.figure(figsize=(12, 4))
        plt.plot(residuos)
        plt.title(f"Residuos del mejor modelo ARIMA{mejor_modelo[0]} para {nombre}")
        plt.xlabel("Fecha")
        plt.ylabel("Residuo")
        plt.grid(True)
        plt.show()

        print("üìå Los residuos deben parecer ruido blanco (media cero, varianza constante y sin patrones claros).")
    else:
        print("\n‚ùå No se pudieron ajustar modelos ARIMA manuales.")

"""*   Para la serie de consumo de Gasolina Superior, se utiliz√≥ la funci√≥n `auto_arima` para identificar el modelo predictivo m√°s adecuado. El proceso de b√∫squeda determin√≥ que el modelo **ARIMA(1, 1, 2)** es el √≥ptimo, al presentar el Criterio de Informaci√≥n de Akaike (AIC) m√°s bajo con un valor de 5257.51. Este modelo incorpora un t√©rmino de diferenciaci√≥n (`d=1`) para hacer la serie estacionaria, un componente autorregresivo (`p=1`) y dos componentes de media m√≥vil (`q=2`).

*   El diagn√≥stico del modelo `ARIMA(1, 1, 2)` es muy positivo. Las pruebas sobre los residuos (errores del modelo) sugieren que se comportan como ruido blanco, lo cual es deseable. La prueba de Ljung-Box (Prob(Q) = 0.63) indica que no hay autocorrelaci√≥n residual significativa, mientras que la prueba de Jarque-Bera (Prob(JB) = 0.93) confirma que los residuos siguen una distribuci√≥n normal. Estos resultados indican que el modelo ha capturado exitosamente la estructura subyacente de la serie temporal.

*   Gasolina Regular:
"""

import warnings
warnings.filterwarnings("ignore")

# Lista de series y nombres
series = [
    (ts_importa_regular, "Gasolina Regular")


]

# Ajuste ARIMA para cada serie
for serie, nombre in series:
    print("\n===================================")
    print(f"üìä Ajuste de modelos ARIMA: {nombre}")
    print("===================================\n")

    # --- Usar auto_arima para sugerir p, d, q ---
    modelo_auto = auto_arima(serie, seasonal=False, trace=True, suppress_warnings=True, stepwise=True)
    print(f"\n===> üìå Modelo ARIMA sugerido por auto_arima para {nombre}:")
    print(modelo_auto.summary())

    # --- Ajustar varios modelos ARIMA manualmente ---
    print("\nüîß Comparando modelos ARIMA manuales:")

    ordenes = [(1,1,1), (2,1,1), (1,1,2), (2,1,2), modelo_auto.order]
    resultados = []

    for orden in ordenes:
        try:
            modelo = ARIMA(serie, order=orden).fit()
            aic = modelo.aic
            bic = modelo.bic
            resultados.append((orden, aic, bic))
            print(f"ARIMA{orden} - AIC: {aic:.2f}, BIC: {bic:.2f}")
        except:
            print(f"‚ö†Ô∏è No se pudo ajustar ARIMA{orden}")

    # --- Elegir mejor modelo seg√∫n AIC ---
    mejor_modelo = sorted(resultados, key=lambda x: x[1])[0]
    print(f"\n‚úÖ Mejor modelo para {nombre} seg√∫n AIC: ARIMA{mejor_modelo[0]} (AIC={mejor_modelo[1]:.2f})")

    # --- Analizar residuos del mejor modelo ---
    modelo_final = ARIMA(serie, order=mejor_modelo[0]).fit()
    residuos = modelo_final.resid

    plt.figure(figsize=(12, 4))
    plt.plot(residuos)
    plt.title(f"Residuos del mejor modelo ARIMA{mejor_modelo[0]} para {nombre}")
    plt.show()

    print("üìå Los residuos deben parecer ruido blanco (sin patrones claros).")

"""*   Para la serie de consumo de Gasolina Regular, el proceso automatizado de `auto_arima` identific√≥ al modelo **ARIMA(3, 1, 3) con intercepto** como el m√°s adecuado, logrando el menor valor AIC de 5173.439. Este modelo es relativamente complejo, utilizando una diferenciaci√≥n (`d=1`) para tratar la tendencia, junto con tres t√©rminos autorregresivos (`p=3`) y tres t√©rminos de media m√≥vil (`q=3`) para capturar la din√°mica de la serie.

*   El diagn√≥stico del modelo revela resultados mixtos. Por un lado, la prueba de Ljung-Box (Prob(Q) = 0.87) es positiva, indicando que los residuos no presentan autocorrelaci√≥n significativa y que la estructura de la serie ha sido bien capturada. Sin embargo, la prueba de Jarque-Bera (Prob(JB) = 0.00) y la de Heterocedasticidad (Prob(H) = 0.00) son problem√°ticas, ya que se√±alan que los residuos no siguen una distribuci√≥n normal y que su varianza no es constante. Esto sugiere que, aunque el modelo es √∫til, podr√≠a mejorarse aplicando una transformaci√≥n a los datos (como la logar√≠tmica) para estabilizar la varianza antes del ajuste.

*   Diesel
"""

import warnings
warnings.filterwarnings("ignore")

# Lista de series y nombres
series = [

    (ts_importa_diesel, "Di√©sel")

]

# Ajuste ARIMA para cada serie
for serie, nombre in series:
    print("\n===================================")
    print(f"üìä Ajuste de modelos ARIMA: {nombre}")
    print("===================================\n")

    # --- Usar auto_arima para sugerir p, d, q ---
    modelo_auto = auto_arima(serie, seasonal=False, trace=True, suppress_warnings=True, stepwise=True)
    print(f"\n===> üìå Modelo ARIMA sugerido por auto_arima para {nombre}:")
    print(modelo_auto.summary())

    # --- Ajustar varios modelos ARIMA manualmente ---
    print("\nüîß Comparando modelos ARIMA manuales:")

    ordenes = [(1,1,1), (2,1,1), (1,1,2), (2,1,2), modelo_auto.order]
    resultados = []

    for orden in ordenes:
        try:
            modelo = ARIMA(serie, order=orden).fit()
            aic = modelo.aic
            bic = modelo.bic
            resultados.append((orden, aic, bic))
            print(f"ARIMA{orden} - AIC: {aic:.2f}, BIC: {bic:.2f}")
        except:
            print(f"‚ö†Ô∏è No se pudo ajustar ARIMA{orden}")

    # --- Elegir mejor modelo seg√∫n AIC ---
    mejor_modelo = sorted(resultados, key=lambda x: x[1])[0]
    print(f"\n‚úÖ Mejor modelo para {nombre} seg√∫n AIC: ARIMA{mejor_modelo[0]} (AIC={mejor_modelo[1]:.2f})")

    # --- Analizar residuos del mejor modelo ---
    modelo_final = ARIMA(serie, order=mejor_modelo[0]).fit()
    residuos = modelo_final.resid

    plt.figure(figsize=(12, 4))
    plt.plot(residuos)
    plt.title(f"Residuos del mejor modelo ARIMA{mejor_modelo[0]} para {nombre}")
    plt.show()

    print("üìå Los residuos deben parecer ruido blanco (sin patrones claros).")

"""*   En el caso de la serie de consumo de Di√©sel, el proceso de `auto_arima` seleccion√≥ un modelo **ARIMA(0, 1, 1)** muy sencillo como el m√°s eficiente, alcanzando un valor AIC de 5569.90. Este modelo consiste en aplicar una diferenciaci√≥n (`d=1`) para corregir la tendencia y un √∫nico t√©rmino de media m√≥vil (`q=1`) para modelar la din√°mica de la serie.

*   El diagn√≥stico del modelo presenta una situaci√≥n similar a la de la Gasolina Regular. Por un lado, la prueba de Ljung-Box (Prob(Q) = 0.48) es favorable, indicando que los residuos no tienen autocorrelaci√≥n. Sin embargo, las pruebas de Jarque-Bera (Prob(JB) = 0.01) y de Heterocedasticidad (Prob(H) = 0.01) fallan, lo que significa que los errores del modelo no son normales y su varianza no es constante. Esto sugiere que el modelo captura bien la dependencia temporal, pero se beneficiar√≠a de una transformaci√≥n previa (como la logar√≠tmica) para estabilizar la varianza de la serie original.

*   Gas Licuado de Petroleo
"""

import warnings
warnings.filterwarnings("ignore")

# Lista de series y nombres
series = [

    (ts_importa_licuado, "Gas Licuado")

]

# Ajuste ARIMA para cada serie
for serie, nombre in series:
    print("\n===================================")
    print(f"üìä Ajuste de modelos ARIMA: {nombre}")
    print("===================================\n")

    # --- Usar auto_arima para sugerir p, d, q ---
    modelo_auto = auto_arima(serie, seasonal=False, trace=True, suppress_warnings=True, stepwise=True)
    print(f"\n===> üìå Modelo ARIMA sugerido por auto_arima para {nombre}:")
    print(modelo_auto.summary())

    # --- Ajustar varios modelos ARIMA manualmente ---
    print("\nüîß Comparando modelos ARIMA manuales:")

    ordenes = [(1,1,1), (2,1,1), (1,1,2), (2,1,2), modelo_auto.order]
    resultados = []

    for orden in ordenes:
        try:
            modelo = ARIMA(serie, order=orden).fit()
            aic = modelo.aic
            bic = modelo.bic
            resultados.append((orden, aic, bic))
            print(f"ARIMA{orden} - AIC: {aic:.2f}, BIC: {bic:.2f}")
        except:
            print(f"‚ö†Ô∏è No se pudo ajustar ARIMA{orden}")

    # --- Elegir mejor modelo seg√∫n AIC ---
    mejor_modelo = sorted(resultados, key=lambda x: x[1])[0]
    print(f"\n‚úÖ Mejor modelo para {nombre} seg√∫n AIC: ARIMA{mejor_modelo[0]} (AIC={mejor_modelo[1]:.2f})")

    # --- Analizar residuos del mejor modelo ---
    modelo_final = ARIMA(serie, order=mejor_modelo[0]).fit()
    residuos = modelo_final.resid

    plt.figure(figsize=(12, 4))
    plt.plot(residuos)
    plt.title(f"Residuos del mejor modelo ARIMA{mejor_modelo[0]} para {nombre}")
    plt.show()

    print("üìå Los residuos deben parecer ruido blanco (sin patrones claros).")

"""*   Para la serie de consumo de Gas Licuado, el proceso de `auto_arima` encontr√≥ un modelo **ARIMA(5, 1, 3) con intercepto** como el de mejor rendimiento global, con un AIC de 5314.125. Sin embargo, en la posterior comparaci√≥n manual de modelos m√°s sencillos, se identific√≥ al **ARIMA(2, 1, 2)** como el mejor de esa lista espec√≠fica, con un AIC de 5316.84. Ambos resultados apuntan a la necesidad de usar una diferenciaci√≥n (`d=1`) y una combinaci√≥n de t√©rminos autorregresivos y de media m√≥vil para modelar la serie.

*   Al analizar el diagn√≥stico del modelo m√°s completo (`ARIMA(5,1,3)`), observamos que los residuos no presentan autocorrelaci√≥n (Prob(Q) = 0.87) y se acercan a la normalidad (Prob(JB) = 0.08). No obstante, la prueba de Heterocedasticidad falla de manera contundente (Prob(H) = 0.00), indicando que la varianza de los errores no es constante. Esto confirma la observaci√≥n inicial de que la serie se beneficiar√≠a enormemente de una transformaci√≥n para estabilizar la varianza (como la logar√≠tmica) antes de aplicar el modelo ARIMA.

II. Consumo:
"""

import warnings
warnings.filterwarnings("ignore")

# --- Series de consumo ---
series_consumo = [
    (ts_consu_superior, "Consumo Gasolina Superior"),
    (ts_consu_regular, "Consumo Gasolina Regular"),
    (ts_consu_diesel, "Consumo Di√©sel"),
    (ts_consu_licuado, "Consumo Gas Licuado")
]

# --- Ajuste ARIMA ---
def ajustar_modelos_arima(series, tipo):
    print(f"\n{'='*50}")
    print(f"üìä Ajuste de modelos ARIMA: {tipo.upper()}")
    print(f"{'='*50}\n")

    for serie, nombre in series:
        print("\n" + "="*40)
        print(f"üìà Serie: {nombre}")
        print("="*40)

        try:
            # Auto ARIMA
            modelo_auto = auto_arima(
                serie,
                seasonal=False,
                trace=True,
                suppress_warnings=True,
                stepwise=True,
                error_action='ignore'
            )

            print(f"\n===> üìå Modelo ARIMA sugerido por auto_arima para {nombre}:")
            print(modelo_auto.summary())

            # Ajuste de modelos manuales
            print("\nüîß Comparando modelos ARIMA manuales:")
            ordenes = [(1,1,1), (2,1,1), (1,1,2), (2,1,2), modelo_auto.order]
            resultados = []

            for orden in ordenes:
                try:
                    serie_frec = serie.asfreq(serie.index.inferred_freq)
                    modelo = ARIMA(serie_frec, order=orden).fit()
                    aic, bic = modelo.aic, modelo.bic
                    resultados.append((orden, aic, bic))
                    print(f"ARIMA{orden} - AIC: {aic:.2f}, BIC: {bic:.2f}")
                except Exception as e:
                    print(f"‚ö†Ô∏è No se pudo ajustar ARIMA{orden}: {e}")

            # Mejor modelo por AIC
            if resultados:
                mejor = sorted(resultados, key=lambda x: x[1])[0]
                print(f"\n‚úÖ Mejor modelo para {nombre} seg√∫n AIC: ARIMA{mejor[0]} (AIC={mejor[1]:.2f})")

                # Residuos del mejor modelo
                modelo_final = ARIMA(serie.asfreq(serie.index.inferred_freq), order=mejor[0]).fit()
                residuos = modelo_final.resid

                plt.figure(figsize=(12, 4))
                plt.plot(residuos)
                plt.title(f"Residuos del mejor modelo ARIMA{mejor[0]} para {nombre}")
                plt.xlabel("Fecha")
                plt.ylabel("Residuo")
                plt.grid(True)
                plt.show()

                print("üìå Los residuos deben parecer ruido blanco (media cero, varianza constante y sin patrones claros).")
            else:
                print("\n‚ùå No se pudieron ajustar modelos ARIMA manuales.")
        except Exception as e:
            print(f"\nüö® Error en {nombre}: {e}")

# --- Ejecutar para consumo ---
ajustar_modelos_arima(series_consumo, "consumo")

"""**g. Modelos Arima**

I. Importaciones
"""

series = [
    (ts_importa_superior, "Gasolina Superior")

]

for ts, name in series:
    print(f"\n==== Serie: {name} ====")

    # Ajustar modelo con auto_arima (busca p,d,q autom√°ticamente)
    modelo_auto = pm.auto_arima(ts, seasonal=False, stepwise=True, suppress_warnings=True, error_action='ignore')

    print("Mejor modelo seg√∫n auto_arima:", modelo_auto.summary())

    # Ajustar el modelo manualmente con statsmodels para analizar residuos
    model = ARIMA(ts, order=modelo_auto.order)
    model_fit = model.fit()

    # Residuos
    resid = model_fit.resid

    # Graficar residuos
    plt.figure(figsize=(12,4))
    plt.subplot(1,2,1)
    resid.plot(title=f"Residuos de {name}")
    plt.subplot(1,2,2)
    plt.acorr(resid, maxlags=40)
    plt.title("Autocorrelaci√≥n residuos")
    plt.show()

    # Estad√≠sticas AIC y BIC
    print(f"AIC: {model_fit.aic:.2f}, BIC: {model_fit.bic:.2f}")

    # Prueba de autocorrelaci√≥n en residuos (Ljung-Box)
    from statsmodels.stats.diagnostic import acorr_ljungbox
    ljung_box = acorr_ljungbox(resid, lags=[10], return_df=True)
    print("Prueba Ljung-Box residuos (p-valor):")
    print(ljung_box)

"""*   **Serie: Gasolina Superior**
    El modelo seleccionado, `ARIMA(1, 1, 2)`, demuestra un ajuste excelente. Los diagn√≥sticos de los residuos son casi perfectos: la prueba de Ljung-Box (p-valor = 0.98) indica que no hay autocorrelaci√≥n residual; la prueba de Jarque-Bera (p-valor = 0.93) confirma que los residuos son normales; y la prueba de heterocedasticidad (p-valor = 0.47) muestra que la varianza es constante. El √∫nico detalle menor es que el segundo t√©rmino de media m√≥vil (`ma.L2`) no es estad√≠sticamente significativo (p-valor = 0.149), pero en general, el modelo es robusto y fiable.
"""

series = [

    (ts_importa_regular, "Gasolina Regular")
]

for ts, name in series:
    print(f"\n==== Serie: {name} ====")

    # Ajustar modelo con auto_arima (busca p,d,q autom√°ticamente)
    modelo_auto = pm.auto_arima(ts, seasonal=False, stepwise=True, suppress_warnings=True, error_action='ignore')

    print("Mejor modelo seg√∫n auto_arima:", modelo_auto.summary())

    # Ajustar el modelo manualmente con statsmodels para analizar residuos
    model = ARIMA(ts, order=modelo_auto.order)
    model_fit = model.fit()

    # Residuos
    resid = model_fit.resid

    # Graficar residuos
    plt.figure(figsize=(12,4))
    plt.subplot(1,2,1)
    resid.plot(title=f"Residuos de {name}")
    plt.subplot(1,2,2)
    plt.acorr(resid, maxlags=40)
    plt.title("Autocorrelaci√≥n residuos")
    plt.show()

    # Estad√≠sticas AIC y BIC
    print(f"AIC: {model_fit.aic:.2f}, BIC: {model_fit.bic:.2f}")

    # Prueba de autocorrelaci√≥n en residuos (Ljung-Box)
    from statsmodels.stats.diagnostic import acorr_ljungbox
    ljung_box = acorr_ljungbox(resid, lags=[10], return_df=True)
    print("Prueba Ljung-Box residuos (p-valor):")
    print(ljung_box)

"""*   **Serie: Gasolina Regular**
    El modelo `ARIMA(3, 1, 3)` captura exitosamente la dependencia temporal de los datos, como lo demuestra el p-valor alto de la prueba de Ljung-Box (0.63). Sin embargo, el modelo muestra debilidades significativas en otros aspectos: las pruebas de Jarque-Bera (p-valor = 0.00) y de heterocedasticidad (p-valor = 0.00) fallan claramente. Esto significa que los residuos no son normales y su varianza no es constante, lo cual confirma que es necesario aplicar una transformaci√≥n a la serie (como la logar√≠tmica) para estabilizar la varianza y mejorar el modelo.
"""

series = [


    (ts_importa_diesel, "Di√©sel")
]

for ts, name in series:
    print(f"\n==== Serie: {name} ====")

    # Ajustar modelo con auto_arima (busca p,d,q autom√°ticamente)
    modelo_auto = pm.auto_arima(ts, seasonal=False, stepwise=True, suppress_warnings=True, error_action='ignore')

    print("Mejor modelo seg√∫n auto_arima:", modelo_auto.summary())

    # Ajustar el modelo manualmente con statsmodels para analizar residuos
    model = ARIMA(ts, order=modelo_auto.order)
    model_fit = model.fit()

    # Residuos
    resid = model_fit.resid

    # Graficar residuos
    plt.figure(figsize=(12,4))
    plt.subplot(1,2,1)
    resid.plot(title=f"Residuos de {name}")
    plt.subplot(1,2,2)
    plt.acorr(resid, maxlags=40)
    plt.title("Autocorrelaci√≥n residuos")
    plt.show()

    # Estad√≠sticas AIC y BIC
    print(f"AIC: {model_fit.aic:.2f}, BIC: {model_fit.bic:.2f}")

    # Prueba de autocorrelaci√≥n en residuos (Ljung-Box)
    from statsmodels.stats.diagnostic import acorr_ljungbox
    ljung_box = acorr_ljungbox(resid, lags=[10], return_df=True)
    print("Prueba Ljung-Box residuos (p-valor):")
    print(ljung_box)

"""*   **Serie: Di√©sel**
    El modelo `ARIMA(0, 1, 1)` es muy simple pero efectivo para eliminar la autocorrelaci√≥n de los residuos (p-valor de Ljung-Box = 0.40). No obstante, al igual que con la Gasolina Regular, el modelo falla en los diagn√≥sticos clave de los residuos. Las pruebas de Jarque-Bera (p-valor = 0.01) y de heterocedasticidad (p-valor = 0.01) indican que los residuos no son normales y su varianza no es constante. Este es un fuerte indicativo de que se requiere una transformaci√≥n de los datos originales para obtener un modelo m√°s v√°lido.
"""

series = [


    (ts_importa_licuado, "Gas Licuado")
]

for ts, name in series:
    print(f"\n==== Serie: {name} ====")

    # Ajustar modelo con auto_arima (busca p,d,q autom√°ticamente)
    modelo_auto = pm.auto_arima(ts, seasonal=False, stepwise=True, suppress_warnings=True, error_action='ignore')

    print("Mejor modelo seg√∫n auto_arima:", modelo_auto.summary())

    # Ajustar el modelo manualmente con statsmodels para analizar residuos
    model = ARIMA(ts, order=modelo_auto.order)
    model_fit = model.fit()

    # Residuos
    resid = model_fit.resid

    # Graficar residuos
    plt.figure(figsize=(12,4))
    plt.subplot(1,2,1)
    resid.plot(title=f"Residuos de {name}")
    plt.subplot(1,2,2)
    plt.acorr(resid, maxlags=40)
    plt.title("Autocorrelaci√≥n residuos")
    plt.show()

    # Estad√≠sticas AIC y BIC
    print(f"AIC: {model_fit.aic:.2f}, BIC: {model_fit.bic:.2f}")

    # Prueba de autocorrelaci√≥n en residuos (Ljung-Box)
    from statsmodels.stats.diagnostic import acorr_ljungbox
    ljung_box = acorr_ljungbox(resid, lags=[10], return_df=True)
    print("Prueba Ljung-Box residuos (p-valor):")
    print(ljung_box)

"""*   **Serie: Gas Licuado**
    El modelo `ARIMA(5, 1, 3)` es complejo pero logra un buen ajuste en dos de tres aspectos cruciales. La prueba de Ljung-Box (p-valor = 0.89) y la de Jarque-Bera (p-valor = 0.08) son exitosas, lo que significa que los residuos no est√°n correlacionados y siguen una distribuci√≥n normal. Sin embargo, su principal deficiencia es la heterocedasticidad (p-valor = 0.00), que indica que la varianza de los errores no es constante. Esto refuerza la idea de que el paso m√°s importante para mejorar este modelo es aplicar una transformaci√≥n que estabilice la varianza.

III. Precios
"""

import warnings
warnings.filterwarnings("ignore")

# --- Series de precios ---
series_precios = [
    (ts_precio_superior, "Precio Gasolina Superior"),
    (ts_precio_regular, "Precio Gasolina Regular"),
    (ts_precio_diesel, "Precio Di√©sel")
    # Agrega ts_precio_licuado si lo tienes
]

# --- Ajuste ARIMA ---
def ajustar_modelos_arima(series, tipo):
    print(f"\n{'='*50}")
    print(f"üìä Ajuste de modelos ARIMA: {tipo.upper()}")
    print(f"{'='*50}\n")

    for serie, nombre in series:
        print("\n" + "="*40)
        print(f"üìà Serie: {nombre}")
        print("="*40)

        try:
            # Auto ARIMA
            modelo_auto = auto_arima(
                serie,
                seasonal=False,
                trace=True,
                suppress_warnings=True,
                stepwise=True,
                error_action='ignore'
            )

            print(f"\n===> üìå Modelo ARIMA sugerido por auto_arima para {nombre}:")
            print(modelo_auto.summary())

            # Ajuste de modelos manuales
            print("\nüîß Comparando modelos ARIMA manuales:")
            ordenes = [(1,1,1), (2,1,1), (1,1,2), (2,1,2), modelo_auto.order]
            resultados = []

            for orden in ordenes:
                try:
                    serie_frec = serie.asfreq(serie.index.inferred_freq)
                    modelo = ARIMA(serie_frec, order=orden).fit()
                    aic, bic = modelo.aic, modelo.bic
                    resultados.append((orden, aic, bic))
                    print(f"ARIMA{orden} - AIC: {aic:.2f}, BIC: {bic:.2f}")
                except Exception as e:
                    print(f"‚ö†Ô∏è No se pudo ajustar ARIMA{orden}: {e}")

            # Mejor modelo por AIC
            if resultados:
                mejor = sorted(resultados, key=lambda x: x[1])[0]
                print(f"\n‚úÖ Mejor modelo para {nombre} seg√∫n AIC: ARIMA{mejor[0]} (AIC={mejor[1]:.2f})")

                # Residuos del mejor modelo
                modelo_final = ARIMA(serie.asfreq(serie.index.inferred_freq), order=mejor[0]).fit()
                residuos = modelo_final.resid

                plt.figure(figsize=(12, 4))
                plt.plot(residuos)
                plt.title(f"Residuos del mejor modelo ARIMA{mejor[0]} para {nombre}")
                plt.xlabel("Fecha")
                plt.ylabel("Residuo")
                plt.grid(True)
                plt.show()

                print("üìå Los residuos deben parecer ruido blanco (media cero, varianza constante y sin patrones claros).")
            else:
                print("\n‚ùå No se pudieron ajustar modelos ARIMA manuales.")
        except Exception as e:
            print(f"\nüö® Error en {nombre}: {e}")

# --- Ejecutar para precios ---
ajustar_modelos_arima(series_precios, "precios")

"""*   **Serie: Precio Gasolina Superior**
    El modelo seleccionado, `ARIMA(5, 2, 1)`, es complejo e indica que la serie necesit√≥ ser diferenciada dos veces (`d=2`) para volverse estacionaria. El modelo captura exitosamente la dependencia temporal, como lo demuestra el p-valor de la prueba Ljung-Box (0.56). Sin embargo, falla estrepitosamente en los diagn√≥sticos de los residuos: las pruebas de Jarque-Bera y de Heterocedasticidad tienen p-valores de 0.00, lo que significa que los errores no son normales y su varianza no es constante. Esto sugiere que el modelo, aunque √∫til, podr√≠a ser inestable para pron√≥sticos debido a la volatilidad no modelada.

*   **Serie: Precio Gasolina Regular**
    En este caso, aunque `auto_arima` sugiri√≥ un modelo extremadamente simple, la comparaci√≥n manual encontr√≥ que un `ARIMA(2, 1, 2)` era significativamente mejor. Analizando los resultados del modelo m√°s simple (`ARIMA(0,1,0)`), vemos un patr√≥n similar a los otros combustibles: la autocorrelaci√≥n se elimina (Prob(Q) = 0.60), pero los residuos no son normales (Prob(JB) = 0.00) y la varianza es claramente no constante (Prob(H) = 0.00). Esto indica que la din√°mica de la serie es demasiado compleja para un modelo ARIMA simple sin una transformaci√≥n previa de los datos.

*   **Serie: Precio Di√©sel**
    El modelo `ARIMA(3, 1, 2)` fue seleccionado como el mejor tanto por `auto_arima` como por la comparaci√≥n manual. Al igual que los dem√°s, es muy eficaz para modelar la estructura de autocorrelaci√≥n (Prob(Q) = 0.96), lo que significa que los residuos no est√°n correlacionados entre s√≠. Sin embargo, tambi√©n falla en las pruebas de Jarque-Bera (Prob(JB) = 0.00) y Heterocedasticidad (Prob(H) = 0.00), lo que confirma que los supuestos del modelo sobre los errores no se cumplen. La no normalidad y la varianza no constante son problemas significativos que deber√≠an ser abordados.
"""

!pip install prophet

"""**h. Modelo: prophet de
Facebook, holt-winters y redes neuronales**

I. Importaciones
"""

from prophet import Prophet
import warnings
warnings.filterwarnings("ignore")
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.preprocessing.sequence import TimeseriesGenerator
import numpy as np

# Funci√≥n para RMSE
def evaluate_model(y_true, y_pred):
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    print(f"RMSE: {rmse:.4f}")
    return rmse

# Comparaci√≥n de modelos
def modelos_comparacion(ts, name):
    print(f"\n==== An√°lisis para {name} ====")
    split = int(len(ts)*0.8)
    train, test = ts[:split], ts[split:]

    train_clean = train.dropna()
    test_clean = test.dropna()

    if len(train_clean) < 2 or len(test_clean) < 1:
        print(f"‚ö†Ô∏è Datos insuficientes para {name}, se omite.")
        return None

    #### 1. Prophet
    df_prophet = train_clean.reset_index()
    df_prophet.columns = ['ds', 'y']
    model_prophet = Prophet()
    model_prophet.fit(df_prophet)
    future = model_prophet.make_future_dataframe(periods=len(test_clean), freq='MS')
    forecast = model_prophet.predict(future)
    pred_prophet = forecast['yhat'][-len(test_clean):].values
    print("üìà Prophet:")
    rmse_prophet = evaluate_model(test_clean.values, pred_prophet)

    #### 2. Holt-Winters
    try:
        model_hw = ExponentialSmoothing(train_clean, trend='add', seasonal='add', seasonal_periods=12).fit()
        pred_hw = model_hw.forecast(len(test_clean))
        print("üìà Holt-Winters (Seasonal):")
        rmse_hw = evaluate_model(test_clean, pred_hw)
    except:
        model_hw = ExponentialSmoothing(train_clean, trend='add', seasonal=None).fit()
        pred_hw = model_hw.forecast(len(test_clean))
        print("üìà Holt-Winters (Non-Seasonal):")
        rmse_hw = evaluate_model(test_clean, pred_hw)

    #### 3. LSTM
    scaler = MinMaxScaler()
    train_scaled = scaler.fit_transform(train_clean.values.reshape(-1,1))
    n_input = 5
    train_gen = TimeseriesGenerator(train_scaled, train_scaled, length=n_input, batch_size=1)
    model_lstm = Sequential([
        LSTM(50, activation='relu', input_shape=(n_input, 1)),
        Dense(1)
    ])
    model_lstm.compile(optimizer='adam', loss='mse')
    model_lstm.fit(train_gen, epochs=20, verbose=0)
    lstm_predictions = []
    current_batch = train_scaled[-n_input:].reshape((1, n_input, 1))
    for i in range(len(test_clean)):
        lstm_pred = model_lstm.predict(current_batch, verbose=0)[0]
        lstm_predictions.append(lstm_pred)
        current_batch = np.append(current_batch[:,1:,:], [[lstm_pred]], axis=1)
    pred_lstm = scaler.inverse_transform(lstm_predictions).flatten()
    print("üìà LSTM:")
    rmse_lstm = evaluate_model(test_clean.values, pred_lstm)

    #### Resumen
    resultados = {
        'Prophet': rmse_prophet,
        'Holt-Winters': rmse_hw,
        'LSTM': rmse_lstm
    }
    mejor = min(resultados, key=resultados.get)
    print(f"\n‚úÖ Mejor modelo para {name}: {mejor}\n")
    return name, resultados

# Series de Importaciones
series_importa = [
    (ts_importa_superior, "Gasolina superior"),
    (ts_importa_regular, "Gasolina regular"),
    (ts_importa_diesel, "Diesel"),
    (ts_importa_licuado, "Gas Licuado")
]

resultados_importa = []
for serie, nombre in series_importa:
    resultado = modelos_comparacion(serie, nombre)
    if resultado:
        resultados_importa.append(resultado)

df_resultados_importa = pd.DataFrame({name: valores for name, valores in resultados_importa}).T
print("\nüìä Tabla final para Importaciones (RMSE):")
print(df_resultados_importa)

"""*   **An√°lisis para Gasolina Superior**
    Se compararon los modelos Prophet, Holt-Winters y LSTM. El modelo **Prophet** demostr√≥ ser el m√°s preciso, obteniendo el Error Cuadr√°tico Medio (RMSE) m√°s bajo con un valor de **170,295.82**. Tanto Holt-Winters (RMSE: 197,250.42) como la red LSTM (RMSE: 232,356.94) tuvieron un rendimiento inferior, por lo que Prophet es el modelo seleccionado para esta serie.

*   **An√°lisis para Gasolina Regular**
    En el caso de la Gasolina Regular, la comparaci√≥n arroj√≥ un resultado diferente. El modelo de **Holt-Winters** super√≥ a los dem√°s, logrando el RMSE m√°s bajo con **158,449.82**. Prophet le sigui√≥ de cerca (RMSE: 165,338.12), mientras que la red LSTM fue la menos precisa (RMSE: 236,269.99). Por lo tanto, Holt-Winters es el mejor modelo para esta serie.

*   **An√°lisis para Di√©sel**
    Para la serie de Di√©sel, el modelo de **Holt-Winters** nuevamente demostr√≥ ser el m√°s eficaz, con un RMSE de **192,890.96**. El modelo Prophet tuvo un error ligeramente mayor (RMSE: 202,518.35) y la red LSTM mostr√≥ un desempe√±o considerablemente m√°s bajo (RMSE: 306,137.50). Se selecciona Holt-Winters como el modelo superior para el pron√≥stico del Di√©sel.

*   **An√°lisis para Gas Licuado**
    Finalmente, para el Gas Licuado, la competencia entre Prophet y Holt-Winters fue muy re√±ida. Sin embargo, el modelo de **Holt-Winters** se impuso por un margen muy estrecho, obteniendo el RMSE m√°s bajo con un valor de **143,309.32**, en comparaci√≥n con el RMSE de 145,168.05 de Prophet. Por su mayor precisi√≥n, Holt-Winters es el modelo preferido.

II: Consumo
"""

from prophet import Prophet
import warnings
warnings.filterwarnings("ignore")
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.preprocessing.sequence import TimeseriesGenerator
import numpy as np

# Funci√≥n para RMSE
def evaluate_model(y_true, y_pred):
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    print(f"RMSE: {rmse:.4f}")
    return rmse

# Comparaci√≥n de modelos
def modelos_comparacion(ts, name):
    print(f"\n==== An√°lisis para {name} ====")
    split = int(len(ts)*0.8)
    train, test = ts[:split], ts[split:]

    train_clean = train.dropna()
    test_clean = test.dropna()

    if len(train_clean) < 2 or len(test_clean) < 1:
        print(f"‚ö†Ô∏è Datos insuficientes para {name}, se omite.")
        return None

    #### 1. Prophet
    df_prophet = train_clean.reset_index()
    df_prophet.columns = ['ds', 'y']
    model_prophet = Prophet()
    model_prophet.fit(df_prophet)
    future = model_prophet.make_future_dataframe(periods=len(test_clean), freq='MS')
    forecast = model_prophet.predict(future)
    pred_prophet = forecast['yhat'][-len(test_clean):].values
    print("üìà Prophet:")
    rmse_prophet = evaluate_model(test_clean.values, pred_prophet)

    #### 2. Holt-Winters
    try:
        model_hw = ExponentialSmoothing(train_clean, trend='add', seasonal='add', seasonal_periods=12).fit()
        pred_hw = model_hw.forecast(len(test_clean))
        print("üìà Holt-Winters (Seasonal):")
        rmse_hw = evaluate_model(test_clean, pred_hw)
    except:
        model_hw = ExponentialSmoothing(train_clean, trend='add', seasonal=None).fit()
        pred_hw = model_hw.forecast(len(test_clean))
        print("üìà Holt-Winters (Non-Seasonal):")
        rmse_hw = evaluate_model(test_clean, pred_hw)

    #### 3. LSTM
    scaler = MinMaxScaler()
    train_scaled = scaler.fit_transform(train_clean.values.reshape(-1,1))
    n_input = 5
    train_gen = TimeseriesGenerator(train_scaled, train_scaled, length=n_input, batch_size=1)
    model_lstm = Sequential([
        LSTM(50, activation='relu', input_shape=(n_input, 1)),
        Dense(1)
    ])
    model_lstm.compile(optimizer='adam', loss='mse')
    model_lstm.fit(train_gen, epochs=20, verbose=0)
    lstm_predictions = []
    current_batch = train_scaled[-n_input:].reshape((1, n_input, 1))
    for i in range(len(test_clean)):
        lstm_pred = model_lstm.predict(current_batch, verbose=0)[0]
        lstm_predictions.append(lstm_pred)
        current_batch = np.append(current_batch[:,1:,:], [[lstm_pred]], axis=1)
    pred_lstm = scaler.inverse_transform(lstm_predictions).flatten()
    print("üìà LSTM:")
    rmse_lstm = evaluate_model(test_clean.values, pred_lstm)

    #### Resumen
    resultados = {
        'Prophet': rmse_prophet,
        'Holt-Winters': rmse_hw,
        'LSTM': rmse_lstm
    }
    mejor = min(resultados, key=resultados.get)
    print(f"\n‚úÖ Mejor modelo para {name}: {mejor}\n")
    return name, resultados

# Series de Consumo
series_consumo = [
    (ts_consu_superior, "Gasolina superior"),
    (ts_consu_regular, "Gasolina regular"),
    (ts_consu_diesel, "Diesel"),
    (ts_consu_licuado, "Gas Licuado")
]

resultados_consumo = []
for serie, nombre in series_consumo:
    resultado = modelos_comparacion(serie, nombre)
    if resultado:
        resultados_consumo.append(resultado)

# Tabla final
df_resultados_consumo = pd.DataFrame({name: valores for name, valores in resultados_consumo}).T
print("\nüìä Tabla final para Consumo (RMSE):")
print(df_resultados_consumo)

"""*   **An√°lisis para Gasolina superior**
    En la competencia de modelos para la Gasolina Superior, **Holt-Winters** result√≥ ser el m√°s preciso, obteniendo el Error Cuadr√°tico Medio (RMSE) m√°s bajo con un valor de **117,540.43**. El modelo Prophet le sigui√≥ de cerca con un RMSE de 122,109.35, mientras que la red LSTM fue la menos precisa (RMSE: 155,388.42). Por lo tanto, Holt-Winters es el modelo preferido para esta serie.

*   **An√°lisis para Gasolina regular**
    Para la Gasolina Regular, el modelo de **Holt-Winters** demostr√≥ una clara superioridad, logrando el RMSE m√°s bajo con **108,358.03**. Tanto Prophet (RMSE: 127,382.72) como la red LSTM (RMSE: 156,118.29) mostraron errores considerablemente mayores. Se concluye que Holt-Winters es el mejor modelo para pronosticar esta serie.

*   **An√°lisis para Diesel**
    En el caso del Diesel, la situaci√≥n se invierte. El modelo **Prophet** es el ganador, con un RMSE de **116,686.79**, superando al modelo de Holt-Winters que obtuvo un RMSE de 124,601.02. Por su mayor precisi√≥n en este caso, se selecciona Prophet como el modelo m√°s adecuado para la serie del Diesel.

    *   **An√°lisis para Gas Licuado**
    Para el Gas Licuado, el modelo **Prophet** se destac√≥ como el m√°s preciso, logrando un RMSE notablemente bajo de **32,097.83**. El modelo de Holt-Winters le sigui√≥ con un error ligeramente superior (RMSE: 34,120.36). Es importante destacar el fallo catastr√≥fico de la red LSTM, que produjo un error desmesuradamente alto, dej√°ndola completamente descartada. Por lo tanto, Prophet es, sin duda, el mejor modelo para esta serie.

*   **An√°lisis de la Tabla Final (Consumo)**
    La tabla resumen de RMSE consolida los resultados y permite una elecci√≥n final clara para cada combustible. El modelo de **Holt-Winters** es el preferido para **Gasolina Superior** y **Gasolina Regular**, al presentar el menor error en ambos casos. Por otro lado, el modelo **Prophet** es el ganador para **Diesel** y **Gas Licuado**. La red neuronal **LSTM** demostr√≥ ser consistentemente la menos precisa en todas las series, y particularmente ineficaz para el Gas Licuado, lo que la descarta como una opci√≥n viable para este conjunto de datos.

III. Precio
"""

from prophet import Prophet
import warnings
warnings.filterwarnings("ignore")
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.preprocessing.sequence import TimeseriesGenerator
import numpy as np

# Funci√≥n para RMSE
def evaluate_model(y_true, y_pred):
    rmse = np.sqrt(mean_squared_error(y_true, y_pred))
    print(f"RMSE: {rmse:.4f}")
    return rmse

# Comparaci√≥n de modelos
def modelos_comparacion(ts, name):
    print(f"\n==== An√°lisis para {name} ====")
    split = int(len(ts)*0.8)
    train, test = ts[:split], ts[split:]

    train_clean = train.dropna()
    test_clean = test.dropna()

    if len(train_clean) < 2 or len(test_clean) < 1:
        print(f"‚ö†Ô∏è Datos insuficientes para {name}, se omite.")
        return None

    #### 1. Prophet
    df_prophet = train_clean.reset_index()
    df_prophet.columns = ['ds', 'y']
    model_prophet = Prophet()
    model_prophet.fit(df_prophet)
    future = model_prophet.make_future_dataframe(periods=len(test_clean), freq='MS')
    forecast = model_prophet.predict(future)
    pred_prophet = forecast['yhat'][-len(test_clean):].values
    print("üìà Prophet:")
    rmse_prophet = evaluate_model(test_clean.values, pred_prophet)

    #### 2. Holt-Winters
    try:
        model_hw = ExponentialSmoothing(train_clean, trend='add', seasonal='add', seasonal_periods=12).fit()
        pred_hw = model_hw.forecast(len(test_clean))
        print("üìà Holt-Winters (Seasonal):")
        rmse_hw = evaluate_model(test_clean, pred_hw)
    except:
        model_hw = ExponentialSmoothing(train_clean, trend='add', seasonal=None).fit()
        pred_hw = model_hw.forecast(len(test_clean))
        print("üìà Holt-Winters (Non-Seasonal):")
        rmse_hw = evaluate_model(test_clean, pred_hw)

    #### 3. LSTM
    scaler = MinMaxScaler()
    train_scaled = scaler.fit_transform(train_clean.values.reshape(-1,1))
    n_input = 5
    train_gen = TimeseriesGenerator(train_scaled, train_scaled, length=n_input, batch_size=1)
    model_lstm = Sequential([
        LSTM(50, activation='relu', input_shape=(n_input, 1)),
        Dense(1)
    ])
    model_lstm.compile(optimizer='adam', loss='mse')
    model_lstm.fit(train_gen, epochs=20, verbose=0)
    lstm_predictions = []
    current_batch = train_scaled[-n_input:].reshape((1, n_input, 1))
    for i in range(len(test_clean)):
        lstm_pred = model_lstm.predict(current_batch, verbose=0)[0]
        lstm_predictions.append(lstm_pred)
        current_batch = np.append(current_batch[:,1:,:], [[lstm_pred]], axis=1)
    pred_lstm = scaler.inverse_transform(lstm_predictions).flatten()
    print("üìà LSTM:")
    rmse_lstm = evaluate_model(test_clean.values, pred_lstm)

    #### Resumen
    resultados = {
        'Prophet': rmse_prophet,
        'Holt-Winters': rmse_hw,
        'LSTM': rmse_lstm
    }
    mejor = min(resultados, key=resultados.get)
    print(f"\n‚úÖ Mejor modelo para {name}: {mejor}\n")
    return name, resultados

# Series de Precios
series_precios = [
    (ts_precio_superior, "Gasolina superior"),
    (ts_precio_regular, "Gasolina regular"),
    (ts_precio_diesel, "Diesel")
]

resultados_precios = []
for serie, nombre in series_precios:
    resultado = modelos_comparacion(serie, nombre)
    if resultado:
        resultados_precios.append(resultado)

# Tabla final
df_resultados_precios = pd.DataFrame({name: valores for name, valores in resultados_precios}).T
print("\nüìä Tabla final para Precios (RMSE):")
print(df_resultados_precios)

"""*   **An√°lisis para Gasolina Superior (Precios)**
    Para la serie de precios de la Gasolina Superior, la red neuronal **LSTM** demostr√≥ una superioridad abrumadora, alcanzando un Error Cuadr√°tico Medio (RMSE) de tan solo **0.5176**. Tanto el modelo de Holt-Winters (RMSE: 1.2701) como Prophet (RMSE: 31.3891) tuvieron un rendimiento significativamente inferior. La precisi√≥n de la LSTM la convierte en la elecci√≥n indiscutible para esta serie.

*   **An√°lisis para Gasolina Regular (Precios)**
    En el caso de la Gasolina Regular, la red **LSTM** tambi√©n se impone como el mejor modelo con un RMSE de **6.0805**. Este resultado es considerablemente mejor que el de Holt-Winters (RMSE: 22.1267) y el de Prophet (RMSE: 56.5942), consolidando a la LSTM como la opci√≥n m√°s precisa para pronosticar los precios de este combustible.

*   **An√°lisis para Diesel (Precios)**
    Para los precios del Diesel, de los modelos probados hasta ahora, **Holt-Winters** es el claro ganador con un RMSE de **12.6857**. El modelo Prophet result√≥ ser notablemente menos preciso con un error de 38.0604. A la espera del resultado de la red LSTM, Holt-Winters se posiciona como el mejor modelo hasta el momento.

## **4) Predicci√≥n de serie para los siguientes 3 a√±os**
"""

def preparar_serie(ts, start_year, start_month):
    """
    Forzar √≠ndice de fechas mensual a partir de un a√±o y mes inicial
    """
    ts = ts.copy()
    fechas = pd.date_range(start=f"{start_year}-{start_month:02d}", periods=len(ts), freq="MS")
    ts.index = fechas
    return ts

def evaluar_series(ts, name, start_year=2001, start_month=1):
    print(f"\n==== Predicci√≥n y Evaluaci√≥n para {name} ====")

    # Corregir fechas
    ts = preparar_serie(ts, start_year, start_month)

    # Dividir en train (70%) y test (30%)
    train_size = int(len(ts) * 0.7)
    train = ts[:train_size]
    test = ts[train_size:]

    # Fechas para test
    if hasattr(test, 'index'):
        fechas_test = test.index
    else:
        fechas_test = pd.date_range(start=f"{train.index[-1] + pd.DateOffset(months=1)}",
                                    periods=len(test), freq='MS')

    # ========================
    # Modelos
    # ========================
    # SARIMAX (1,1,2)
    model_111 = SARIMAX(train, order=(1,1,2), seasonal_order=(0,0,0,0)).fit(disp=False)
    pred_111 = model_111.forecast(steps=len(test))

    # SARIMAX (2,1,3)
    model_212 = SARIMAX(train, order=(2,1,3), seasonal_order=(0,0,0,0)).fit(disp=False)
    pred_212 = model_212.forecast(steps=len(test))

    # Prophet
    df_prophet = pd.DataFrame({'ds': train.index, 'y': train.values})
    model_prophet = Prophet()
    model_prophet.fit(df_prophet)
    future_df = pd.DataFrame({'ds': fechas_test})
    forecast_prophet = model_prophet.predict(future_df)
    pred_prophet = forecast_prophet['yhat'].values

    # ========================
    # RMSE
    # ========================
    rmse_111 = np.sqrt(mean_squared_error(test, pred_111))
    rmse_212 = np.sqrt(mean_squared_error(test, pred_212))
    rmse_prophet = np.sqrt(mean_squared_error(test, pred_prophet))
    print("\nüìâ Errores (RMSE):")
    print(f"SARIMAX (1,1,2): {rmse_111:.2f}")
    print(f"SARIMAX (2,1,3): {rmse_212:.2f}")
    print(f"Prophet: {rmse_prophet:.2f}")

    # ========================
    # Gr√°fico
    # ========================
    plt.figure(figsize=(15, 8))
    plt.plot(fechas_test, test, 'o-', label='Valores Reales', color='black', markersize=3, alpha=0.8)
    plt.plot(fechas_test, pred_111, 's-', label='SARIMAX (1,1,2)', color='blue', markersize=2, alpha=0.7)
    plt.plot(fechas_test, pred_212, '^-', label='SARIMAX (2,1,3)', color='red', markersize=2, alpha=0.7)
    plt.plot(fechas_test, pred_prophet, 'd-', label='Prophet', color='green', markersize=2, alpha=0.7)

    plt.title(f'Comparaci√≥n de Predicciones vs Valores Reales ({name})', fontsize=16)
    plt.xlabel('Fecha', fontsize=12)
    plt.ylabel('Valores', fontsize=12)
    plt.legend(fontsize=10)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

    # ========================
    # Tabla comparativa
    # ========================
    df_resultados = pd.DataFrame({
        'Fecha': fechas_test,
        'Real': test.values,
        'SARIMAX (1,1,2)': pred_111,
        'SARIMAX (2,1,3)': pred_212,
        'Prophet': pred_prophet
    })
    print("\nüìã Comparaci√≥n de Predicciones vs Reales:")
    print(df_resultados.round(2).head(12))  # Mostrar primeras filas

# ========================
# üöÄ Ejecutar para cada serie
# ========================
# Cambia el start_year/start_month si tu serie empieza en otro a√±o
evaluar_series(ts_importa_superior, "Gasolina Superior", start_year=2001, start_month=1)
evaluar_series(ts_importa_diesel, "Di√©sel", start_year=2001, start_month=1)
evaluar_series(ts_importa_regular, "Gasolina Regular", start_year=2001, start_month=1)

evaluar_series(ts_importa_licuado, "Gas Licuado", start_year=2001, start_month=1)

"""*   **An√°lisis para Importaciones de Gasolina Superior**
    La evaluaci√≥n de los modelos muestra que **Prophet** es claramente superior. Los modelos SARIMAX generan una predicci√≥n casi plana, incapaz de seguir la tendencia o la estacionalidad de los datos. Esto se confirma con el Error Cuadr√°tico Medio (RMSE), donde Prophet obtiene un valor de **137,413.03**, considerablemente m√°s bajo que el de los modelos SARIMAX (ambos alrededor de 174,478). La predicci√≥n de Prophet es **moderadamente buena**; captura la tendencia y el patr√≥n estacional, pero subestima la magnitud de los picos y valles m√°s extremos.

*   **An√°lisis para Importaciones de Gasolina Regular**
    En este caso, el resultado es muy similar. El modelo **Prophet** es el claro ganador con un RMSE de **149,760.49**, demostrando ser mucho m√°s preciso que los modelos SARIMAX, cuyos errores superan los 206,000. Al igual que con la gasolina superior, los modelos SARIMAX no logran capturar la din√°mica compleja de la serie. La predicci√≥n de Prophet es **aceptable**, ya que sigue la tendencia y la estacionalidad, pero no logra predecir la alta volatilidad de los valores reales.

*   **An√°lisis para Importaciones de Di√©sel**
    Nuevamente, **Prophet** se establece como el modelo m√°s eficaz con un RMSE de **223,864.15**, muy por debajo de los errores de los modelos SARIMAX (superiores a 343,000). Esto indica que los modelos SARIMAX son inadecuados para esta serie. La predicci√≥n de Prophet es **la m√°s √∫til de las tres**, ya que logra seguir la tendencia y la forma general de los datos, aunque, como en los otros casos, no captura la magnitud total de la volatilidad, lo que la califica como una predicci√≥n **moderadamente buena**.

*   **An√°lisis para Importaciones de Gas Licuado**
    La gr√°fica y los datos del RMSE para el Gas Licuado confirman el patr√≥n. El modelo **Prophet** es el mejor, con un error de **132,388.35**, mientras que los modelos SARIMAX (con errores sobre 175,000) producen una predicci√≥n plana e in√∫til. La predicci√≥n de Prophet es **regular**; identifica correctamente la tendencia general al alza y la estacionalidad, pero subestima consistentemente los valores reales, especialmente en los a√±os m√°s recientes. Es √∫til para entender la direcci√≥n del mercado, pero no para predecir vol√∫menes exactos.

II. Consumo
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX
from prophet import Prophet
from sklearn.metrics import mean_squared_error

def preparar_serie(ts, start_year, start_month):
    ts = ts.copy()
    fechas = pd.date_range(start=f"{start_year}-{start_month:02d}", periods=len(ts), freq="MS")
    ts.index = fechas
    return ts

def evaluar_series(ts, name, start_year=2001, start_month=1):
    print(f"\n==== Predicci√≥n y Evaluaci√≥n para {name} ====")

    ts = preparar_serie(ts, start_year, start_month)

    train_size = int(len(ts) * 0.7)
    train = ts[:train_size]
    test = ts[train_size:]

    fechas_test = test.index

    model_111 = SARIMAX(train, order=(1,1,2), seasonal_order=(0,0,0,0)).fit(disp=False)
    pred_111 = model_111.forecast(steps=len(test))

    model_212 = SARIMAX(train, order=(2,1,3), seasonal_order=(0,0,0,0)).fit(disp=False)
    pred_212 = model_212.forecast(steps=len(test))

    df_prophet = pd.DataFrame({'ds': train.index, 'y': train.values})
    model_prophet = Prophet()
    model_prophet.fit(df_prophet)
    future_df = pd.DataFrame({'ds': fechas_test})
    forecast_prophet = model_prophet.predict(future_df)
    pred_prophet = forecast_prophet['yhat'].values

    rmse_111 = np.sqrt(mean_squared_error(test, pred_111))
    rmse_212 = np.sqrt(mean_squared_error(test, pred_212))
    rmse_prophet = np.sqrt(mean_squared_error(test, pred_prophet))

    print("\nüìâ Errores (RMSE):")
    print(f"SARIMAX (1,1,2): {rmse_111:.2f}")
    print(f"SARIMAX (2,1,3): {rmse_212:.2f}")
    print(f"Prophet: {rmse_prophet:.2f}")

    plt.figure(figsize=(15, 8))
    plt.plot(fechas_test, test, 'o-', label='Valores Reales', color='black', markersize=3, alpha=0.8)
    plt.plot(fechas_test, pred_111, 's-', label='SARIMAX (1,1,2)', color='blue', markersize=2, alpha=0.7)
    plt.plot(fechas_test, pred_212, '^-', label='SARIMAX (2,1,3)', color='red', markersize=2, alpha=0.7)
    plt.plot(fechas_test, pred_prophet, 'd-', label='Prophet', color='green', markersize=2, alpha=0.7)

    plt.title(f'Comparaci√≥n de Predicciones vs Valores Reales ({name})', fontsize=16)
    plt.xlabel('Fecha', fontsize=12)
    plt.ylabel('Valores', fontsize=12)
    plt.legend(fontsize=10)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

    df_resultados = pd.DataFrame({
        'Fecha': fechas_test,
        'Real': test.values,
        'SARIMAX (1,1,2)': pred_111,
        'SARIMAX (2,1,3)': pred_212,
        'Prophet': pred_prophet
    })
    print("\nüìã Comparaci√≥n de Predicciones vs Reales:")
    print(df_resultados.round(2).head(12))

# Ejemplo: cambia estos por tus series de consumo
series_consumo = [
    (ts_consu_superior, "Gasolina Superior"),
    (ts_consu_regular, "Gasolina Regular"),
    (ts_consu_diesel, "Di√©sel"),
    (ts_consu_licuado, "Gas Licuado")
]

for ts, nombre in series_consumo:
    evaluar_series(ts, nombre, start_year=2001, start_month=1)

"""*   **An√°lisis de la Predicci√≥n para Gas Licuado**
    La evaluaci√≥n de los modelos para el Gas Licuado muestra un resultado muy claro. Visualmente, los modelos **SARIMAX** (l√≠neas azul y roja) fallan por completo al generar una predicci√≥n casi plana, incapaz de seguir la evidente tendencia creciente y la estacionalidad de los datos reales. En contraste, el modelo **Prophet** (l√≠nea verde) s√≠ logra capturar la tendencia ascendente y los patrones estacionales, aunque de forma imperfecta.

*   **Evaluaci√≥n del Rendimiento de los Modelos**
    Los Errores Cuadr√°ticos Medios (RMSE) confirman lo que la gr√°fica muestra. El modelo **Prophet es el ganador indiscutible** con un RMSE de **61,937.01**, el m√°s bajo de los tres. Los modelos SARIMAX tienen errores considerablemente m√°s altos (74,952.37 y 76,490.81), validando su pobre desempe√±o y su incapacidad para modelar esta serie de tiempo compleja.

*   **Calidad de la Mejor Predicci√≥n (Prophet)**
    La predicci√≥n de Prophet es **aceptable, pero con limitaciones importantes**. Su mayor acierto es identificar correctamente la tendencia alcista a largo plazo y la naturaleza estacional del consumo. Sin embargo, su principal defecto es que **subestima sistem√°ticamente los valores reales**, especialmente despu√©s de 2016, cuando el consumo real se dispara. El modelo sigue la forma de los datos, pero no su magnitud. Por lo tanto, la predicci√≥n es √∫til para entender la direcci√≥n general del mercado, pero no es lo suficientemente precisa para estimar los vol√∫menes exactos de consumo.

III. Precio
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX
from prophet import Prophet
from sklearn.metrics import mean_squared_error

def preparar_serie(ts, start_year, start_month):
    """
    Forzar √≠ndice de fechas mensual a partir de un a√±o y mes inicial
    """
    ts = ts.copy()
    fechas = pd.date_range(start=f"{start_year}-{start_month:02d}", periods=len(ts), freq="MS")
    ts.index = fechas
    return ts

def evaluar_prediccion_3_anios(ts, name, start_year=2001, start_month=1):
    print(f"\n==== Predicci√≥n (√∫ltimos 3 a√±os) para {name} ====")

    # Asegurar fechas correctas
    ts = preparar_serie(ts, start_year, start_month)

    # Dividir en train y test (datos hasta 2024 -> train, 2025 -> test)
    cutoff_date = '2025-01-01'
    train = ts[ts.index < cutoff_date]
    test = ts[ts.index >= cutoff_date]

    print(f"üìÖ Entrenamiento: {train.index[0].date()} a {train.index[-1].date()}")
    print(f"üìÖ Prueba: {test.index[0].date()} a {test.index[-1].date()}")

    # ========================
    # Modelos
    # ========================

    # SARIMAX (1,1,2)
    model_111 = SARIMAX(train, order=(1,1,2), seasonal_order=(0,0,0,0)).fit(disp=False)
    pred_111 = model_111.forecast(steps=len(test))

    # SARIMAX (2,1,3)
    model_212 = SARIMAX(train, order=(2,1,3), seasonal_order=(0,0,0,0)).fit(disp=False)
    pred_212 = model_212.forecast(steps=len(test))

    # Prophet
    df_prophet = pd.DataFrame({'ds': train.index, 'y': train.values})
    model_prophet = Prophet()
    model_prophet.fit(df_prophet)
    future_df = pd.DataFrame({'ds': test.index})
    forecast_prophet = model_prophet.predict(future_df)
    pred_prophet = forecast_prophet['yhat'].values

    # ========================
    # RMSE
    # ========================
    rmse_111 = np.sqrt(mean_squared_error(test, pred_111))
    rmse_212 = np.sqrt(mean_squared_error(test, pred_212))
    rmse_prophet = np.sqrt(mean_squared_error(test, pred_prophet))
    print("\nüìâ Errores (RMSE):")
    print(f"SARIMAX (1,1,2): {rmse_111:.2f}")
    print(f"SARIMAX (2,1,3): {rmse_212:.2f}")
    print(f"Prophet: {rmse_prophet:.2f}")

    # ========================
    # Gr√°fico
    # ========================
    plt.figure(figsize=(15, 8))
    plt.plot(test.index, test, 'o-', label='Valores Reales (2025)', color='black', markersize=3, alpha=0.8)
    plt.plot(test.index, pred_111, 's-', label='SARIMAX (1,1,2)', color='blue', markersize=2, alpha=0.7)
    plt.plot(test.index, pred_212, '^-', label='SARIMAX (2,1,3)', color='red', markersize=2, alpha=0.7)
    plt.plot(test.index, pred_prophet, 'd-', label='Prophet', color='green', markersize=2, alpha=0.7)

    plt.title(f'Predicci√≥n para los √∫ltimos 3 a√±os ({name})', fontsize=16)
    plt.xlabel('Fecha', fontsize=12)
    plt.ylabel('Precio', fontsize=12)
    plt.legend(fontsize=10)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

    # ========================
    # Tabla comparativa
    # ========================
    df_resultados = pd.DataFrame({
        'Fecha': test.index,
        'Real': test.values,
        'SARIMAX (1,1,2)': pred_111,
        'SARIMAX (2,1,3)': pred_212,
        'Prophet': pred_prophet
    })
    print("\nüìã Comparaci√≥n de Predicciones vs Reales:")
    print(df_resultados.round(2).head(12))  # Mostrar primeras filas

# ========================
# üöÄ Ejecutar para cada serie de precios
# ========================
series_precios = [
    (ts_precio_superior, "Gasolina Superior"),
    (ts_precio_regular, "Gasolina Regular"),
    (ts_precio_diesel, "Di√©sel")
]

for ts, nombre in series_precios:
    evaluar_prediccion_3_anios(ts, nombre, start_year=2001, start_month=1)

"""*   **An√°lisis para Gasolina superior (Precios)**
    Para la serie de precios de la Gasolina Superior, la red neuronal **LSTM** demostr√≥ una superioridad abrumadora, alcanzando un Error Cuadr√°tico Medio (RMSE) de tan solo **0.5176**. Tanto el modelo de Holt-Winters (RMSE: 1.2701) como Prophet (RMSE: 31.3891) tuvieron un rendimiento significativamente inferior. La precisi√≥n de la LSTM la convierte en la elecci√≥n indiscutible para esta serie.

*   **An√°lisis para Gasolina regular (Precios)**
    En el caso de la Gasolina Regular, la red **LSTM** tambi√©n se impone como el mejor modelo con un RMSE de **6.0805**. Este resultado es considerablemente mejor que el de Holt-Winters (RMSE: 22.1267) y el de Prophet (RMSE: 56.5942), consolidando a la LSTM como la opci√≥n m√°s precisa para pronosticar los precios de este combustible.

*   **An√°lisis para Diesel (Precios)**
    Para los precios del Diesel, el resultado de la predicci√≥n a futuro es muy revelador. La gr√°fica muestra que **todos los modelos fallan estrepitosamente** en capturar la din√°mica real de la serie. Los modelos SARIMAX (l√≠neas roja y azul) generan una predicci√≥n completamente plana, mientras que Prophet (l√≠nea verde) proyecta una tendencia decreciente que ignora por completo la alta volatilidad y los cambios estructurales. Aunque los modelos SARIMAX obtienen un RMSE ligeramente mejor (3.59 vs 8.45 de Prophet), esto es meramente accidental. Ninguno de los modelos es fiable, y sus predicciones deben considerarse **malas** y poco √∫tiles para la toma de decisiones.

## **5) Predicci√≥n de serie para 2025**
"""

def prediccion_restante_2025(ts, name):
    print(f"\n==== Predicci√≥n junio-diciembre 2025 para {name} ====")

    cutoff_date = '2025-06-01'
    train = ts[ts.index < cutoff_date]
    test = ts[ts.index >= cutoff_date]

    steps = 7
    future_index = pd.date_range(start='2025-06-01', periods=steps, freq='MS')

    # Modelos
    model_sarimax = SARIMAX(train, order=(1,1,2), seasonal_order=(0,0,0,0)).fit(disp=False)
    pred_sarimax = model_sarimax.forecast(steps=steps)

    model_hw = ExponentialSmoothing(train, trend='add', seasonal=None).fit()
    pred_hw = model_hw.forecast(steps)

    df_prophet = pd.DataFrame({'ds': train.index, 'y': train.values})
    model_prophet = Prophet()
    model_prophet.fit(df_prophet)
    future_df = pd.DataFrame({'ds': future_index})
    forecast = model_prophet.predict(future_df)
    pred_prophet = forecast['yhat'].values

    # Gr√°fico enfocado en 2025
    plt.figure(figsize=(12,6))

    # Mostrar datos reales de enero a mayo 2025
    plt.plot(train.index, train, label='Datos reales enero-mayo 2025', color='black', linewidth=2)

    # Mostrar predicciones junio-diciembre
    plt.plot(future_index, pred_sarimax, label='SARIMAX', linestyle='--', color='blue')
    plt.plot(future_index, pred_hw, label='Holt-Winters', linestyle='--', color='red')
    plt.plot(future_index, pred_prophet, label='Prophet', linestyle='--', color='green')

    # Mostrar datos reales junio-diciembre si existen
    if not test.empty:
        plt.plot(test.index, test, label='Datos reales junio-diciembre 2025', color='orange', linewidth=2)

    plt.title(f'Predicci√≥n junio-diciembre 2025 para {name}')
    plt.xlabel('Fecha')
    plt.ylabel('Valor')
    plt.xlim(pd.Timestamp('2025-01-01'), pd.Timestamp('2025-12-31'))  # Limitar solo a 2025
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

    # Tabla con resultados
    df_preds = pd.DataFrame({
        'Fecha': future_index,
        'SARIMAX': pred_sarimax.values,
        'Holt-Winters': pred_hw.values,
        'Prophet': pred_prophet,
        'Real': test.values if not test.empty else [np.nan]*steps
    })
    print("\nüìã Predicciones junio-diciembre 2025:")
    print(df_preds.round(2))

    if not test.empty:
        rmse_sarimax = np.sqrt(mean_squared_error(test, pred_sarimax))
        rmse_hw = np.sqrt(mean_squared_error(test, pred_hw))
        rmse_prophet = np.sqrt(mean_squared_error(test, pred_prophet))
        print(f"\nüìè RMSE:")
        print(f"SARIMAX: {rmse_sarimax:.2f}")
        print(f"Holt-Winters: {rmse_hw:.2f}")
        print(f"Prophet: {rmse_prophet:.2f}")
    else:
        print("‚ö†Ô∏è No hay datos reales de junio-diciembre 2025 para evaluar.")

# Ejecuta para cada serie
prediccion_restante_2025(ts_importa_superior, "Gasolina Superior")
prediccion_restante_2025(ts_importa_regular, "Gasolina Regular")
prediccion_restante_2025(ts_importa_diesel, "Di√©sel")
prediccion_restante_2025(ts_importa_licuado, "Gas Licuado")

"""*   **Evaluaci√≥n de las Predicciones (junio-diciembre 2025)**
    En el caso de las importaciones, se repite la misma din√°mica. Para Gasolina Superior, Regular y Gas Licuado, los modelos **SARIMAX** y **Holt-Winters** proyectan un nivel de importaciones muy estable y sin crecimiento. Por otro lado, **Prophet** anticipa un volumen de importaciones considerablemente mayor y, en general, con una tendencia al alza. El caso m√°s incierto es el del Di√©sel, donde los tres modelos ofrecen predicciones con tendencias completamente diferentes, resaltando una gran incertidumbre en el pron√≥stico.

*   **Comparaci√≥n con la Realidad (enero-mayo 2025)**
    Al igual que con las series de consumo, las gr√°ficas de predicci√≥n de importaciones **omiten la l√≠nea de datos reales correspondientes a enero-mayo de 2025**. Esta omisi√≥n impide realizar una evaluaci√≥n cr√≠tica para saber qu√© modelo ha sido m√°s preciso hasta la fecha. Sin comparar las proyecciones con los datos reales, no se puede determinar si la visi√≥n conservadora de SARIMAX y Holt-Winters o la visi√≥n de crecimiento de Prophet es la m√°s acertada para el resto del a√±o.

II. Consumo
"""

def prediccion_restante_2025_consumo(ts, name):
    print(f"\n==== Predicci√≥n junio-diciembre 2025 para {name} ====")

    cutoff_date = '2025-06-01'
    train = ts[ts.index < cutoff_date]
    test = ts[ts.index >= cutoff_date]

    steps = 7
    future_index = pd.date_range(start='2025-06-01', periods=steps, freq='MS')

    # Modelos
    model_sarimax = SARIMAX(train, order=(1,1,2), seasonal_order=(0,0,0,0)).fit(disp=False)
    pred_sarimax = model_sarimax.forecast(steps=steps)

    model_hw = ExponentialSmoothing(train, trend='add', seasonal=None).fit()
    pred_hw = model_hw.forecast(steps)

    df_prophet = pd.DataFrame({'ds': train.index, 'y': train.values})
    model_prophet = Prophet()
    model_prophet.fit(df_prophet)
    future_df = pd.DataFrame({'ds': future_index})
    forecast = model_prophet.predict(future_df)
    pred_prophet = forecast['yhat'].values

    # Gr√°fico
    plt.figure(figsize=(12,6))
    plt.plot(train.index, train, label='Datos reales enero-mayo 2025', color='black', linewidth=2)
    plt.plot(future_index, pred_sarimax, label='SARIMAX', linestyle='--', color='blue')
    plt.plot(future_index, pred_hw, label='Holt-Winters', linestyle='--', color='red')
    plt.plot(future_index, pred_prophet, label='Prophet', linestyle='--', color='green')
    if not test.empty:
        plt.plot(test.index, test, label='Datos reales junio-diciembre 2025', color='orange', linewidth=2)

    plt.title(f'Predicci√≥n junio-diciembre 2025 para {name}')
    plt.xlabel('Fecha')
    plt.ylabel('Consumo')
    plt.xlim(pd.Timestamp('2025-01-01'), pd.Timestamp('2025-12-31'))
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

    # Tabla
    df_preds = pd.DataFrame({
        'Fecha': future_index,
        'SARIMAX': pred_sarimax.values,
        'Holt-Winters': pred_hw.values,
        'Prophet': pred_prophet,
        'Real': test.values if not test.empty else [np.nan]*steps
    })
    print("\nüìã Predicciones junio-diciembre 2025:")
    print(df_preds.round(2))

    if not test.empty:
        rmse_sarimax = np.sqrt(mean_squared_error(test, pred_sarimax))
        rmse_hw = np.sqrt(mean_squared_error(test, pred_hw))
        rmse_prophet = np.sqrt(mean_squared_error(test, pred_prophet))
        print(f"\nüìè RMSE:")
        print(f"SARIMAX: {rmse_sarimax:.2f}")
        print(f"Holt-Winters: {rmse_hw:.2f}")
        print(f"Prophet: {rmse_prophet:.2f}")
    else:
        print("‚ö†Ô∏è No hay datos reales de junio-diciembre 2025 para evaluar.")


# Ejecuta para cada serie de consumo
series_consumo = [
    (ts_consu_superior, "Gasolina superior"),
    (ts_consu_regular, "Gasolina regular"),
    (ts_consu_diesel, "Diesel"),
    (ts_consu_licuado, "Gas Licuado")
]

for ts, nombre in series_consumo:
    prediccion_restante_2025_consumo(ts, nombre)

"""*   **Evaluaci√≥n de las Predicciones (junio-diciembre 2025)**
    Para las cuatro series de consumo (Gasolina Superior, Regular, Di√©sel y Gas Licuado), se observa un patr√≥n consistente: los modelos **SARIMAX** y **Holt-Winters** ofrecen pron√≥sticos muy conservadores, prediciendo un nivel de consumo pr√°cticamente plano y estable para el resto del a√±o. En marcado contraste, el modelo **Prophet** es mucho m√°s optimista, anticipando en todos los casos una tendencia creciente y niveles de consumo significativamente m√°s altos. En el caso del Di√©sel, la divergencia es a√∫n m√°s notoria, ya que SARIMAX y Holt-Winters predicen tendencias opuestas (una creciente y otra decreciente, respectivamente).

*   **Comparaci√≥n con la Realidad (enero-mayo 2025)**
    A pesar de que la leyenda de las gr√°ficas menciona "Datos reales enero-mayo 2025", esta l√≠nea **no se visualiza en ninguna de las cuatro gr√°ficas de consumo**. Por este motivo, es imposible determinar cu√°l de los modelos se ha apegado m√°s a la realidad en los meses ya transcurridos del a√±o. Para poder validar qu√© escenario (el conservador de SARIMAX/Holt-Winters o el optimista de Prophet) es m√°s plausible, ser√≠a indispensable comparar las predicciones con los datos de consumo reales observados en ese per√≠odo.

III. Precios
"""

def prediccion_restante_2025_precios(ts, name):
    print(f"\n==== Predicci√≥n junio-diciembre 2025 para {name} ====")

    cutoff_date = '2025-06-01'
    train = ts[ts.index < cutoff_date]
    test = ts[ts.index >= cutoff_date]

    steps = 7
    future_index = pd.date_range(start='2025-06-01', periods=steps, freq='MS')

    # Modelos
    model_sarimax = SARIMAX(train, order=(1,1,2), seasonal_order=(0,0,0,0)).fit(disp=False)
    pred_sarimax = model_sarimax.forecast(steps=steps)

    model_hw = ExponentialSmoothing(train, trend='add', seasonal=None).fit()
    pred_hw = model_hw.forecast(steps)

    df_prophet = pd.DataFrame({'ds': train.index, 'y': train.values})
    model_prophet = Prophet()
    model_prophet.fit(df_prophet)
    future_df = pd.DataFrame({'ds': future_index})
    forecast = model_prophet.predict(future_df)
    pred_prophet = forecast['yhat'].values

    # Gr√°fico
    plt.figure(figsize=(12,6))
    plt.plot(train.index, train, label='Datos reales enero-mayo 2025', color='black', linewidth=2)
    plt.plot(future_index, pred_sarimax, label='SARIMAX', linestyle='--', color='blue')
    plt.plot(future_index, pred_hw, label='Holt-Winters', linestyle='--', color='red')
    plt.plot(future_index, pred_prophet, label='Prophet', linestyle='--', color='green')
    if not test.empty:
        plt.plot(test.index, test, label='Datos reales junio-diciembre 2025', color='orange', linewidth=2)

    plt.title(f'Predicci√≥n junio-diciembre 2025 para {name}')
    plt.xlabel('Fecha')
    plt.ylabel('Precio')
    plt.xlim(pd.Timestamp('2025-01-01'), pd.Timestamp('2025-12-31'))
    plt.legend()
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

    # Tabla
    df_preds = pd.DataFrame({
        'Fecha': future_index,
        'SARIMAX': pred_sarimax.values,
        'Holt-Winters': pred_hw.values,
        'Prophet': pred_prophet,
        'Real': test.values if not test.empty else [np.nan]*steps
    })
    print("\nüìã Predicciones junio-diciembre 2025:")
    print(df_preds.round(2))

    if not test.empty:
        rmse_sarimax = np.sqrt(mean_squared_error(test, pred_sarimax))
        rmse_hw = np.sqrt(mean_squared_error(test, pred_hw))
        rmse_prophet = np.sqrt(mean_squared_error(test, pred_prophet))
        print(f"\nüìè RMSE:")
        print(f"SARIMAX: {rmse_sarimax:.2f}")
        print(f"Holt-Winters: {rmse_hw:.2f}")
        print(f"Prophet: {rmse_prophet:.2f}")
    else:
        print("‚ö†Ô∏è No hay datos reales de junio-diciembre 2025 para evaluar.")


# Ejecuta para cada serie de precios
prediccion_restante_2025_precios(ts_precio_superior, "Gasolina Superior")
prediccion_restante_2025_precios(ts_precio_regular, "Gasolina Regular")
prediccion_restante_2025_precios(ts_precio_diesel, "Di√©sel")

"""*   **Predicci√≥n para Gasolina Superior**
    Los tres modelos coinciden en predecir una notable estabilidad de precios para el resto del a√±o. **SARIMAX** y **Holt-Winters** pronostican un precio pr√°cticamente fijo en 30.0. **Prophet** es ligeramente m√°s pesimista, proyectando una leve tendencia a la baja desde 28.8 a 28.2. En general, no se anticipan grandes cambios.

*   **Predicci√≥n para Gasolina Regular**
    Aqu√≠ existe una divergencia extrema. **SARIMAX** y **Holt-Winters** son muy conservadores, prediciendo un precio estable y plano alrededor de 32.5. En cambio, **Prophet** proyecta un escenario radicalmente distinto, con una fuerte tendencia alcista que llevar√≠a el precio desde 47.5 hasta superar los 57.0 a final de a√±o. Esta enorme discrepancia sugiere una alta incertidumbre en el pron√≥stico.

*   **Predicci√≥n para Di√©sel**
    El patr√≥n es muy similar al de la gasolina regular. **SARIMAX** y **Holt-Winters** coinciden en un pron√≥stico de precios muy estables, fijos en torno a 31.0. Por otro lado, **Prophet** anticipa una fuerte subida, con precios que se mueven en un rango de 40.0 a 47.0. La diferencia entre las predicciones es abismal, lo que indica que los modelos han interpretado la historia de la serie de maneras fundamentalmente opuestas.

*   **Evaluaci√≥n contra la Realidad (enero-mayo 2025)**
    En las tres gr√°ficas, aunque la leyenda menciona "Datos reales enero-mayo 2025", esta l√≠nea no se muestra en la visualizaci√≥n. Por lo tanto, **no es posible determinar cu√°l de estas proyecciones se ha apegado m√°s a la realidad** en los meses ya transcurridos del a√±o. Para validar los modelos, ser√≠a crucial comparar estas predicciones con los precios reales observados en ese per√≠odo.

## **6) Comportamiento de las series en Pandemia**

I. Consumo
"""

try:
    _ = ts_consumo_superior_test
    _ = ts_consumo_regular_test
    _ = ts_consumo_diesel_test
    _ = ts_consumo_licuado_test
    _ = y_test_superior
    _ = y_test_regular
    _ = y_test_diesel
    _ = y_test_licuado
except NameError:
    # Crear datos de ejemplo si no existen
    fechas_ejemplo_inicio = '2018-01-01'
    fechas_ejemplo_fin = '2025-12-31'
    fechas_ejemplo_rango = pd.date_range(start=fechas_ejemplo_inicio, end=fechas_ejemplo_fin, freq='MS')
    n_puntos_ejemplo = len(fechas_ejemplo_rango)

    # Series de prueba para cada combustible
    ts_consumo_superior_test = pd.Series(np.random.rand(n_puntos_ejemplo), index=fechas_ejemplo_rango)
    ts_consumo_regular_test = pd.Series(np.random.rand(n_puntos_ejemplo), index=fechas_ejemplo_rango)
    ts_consumo_diesel_test = pd.Series(np.random.rand(n_puntos_ejemplo), index=fechas_ejemplo_rango)
    ts_consumo_licuado_test = pd.Series(np.random.rand(n_puntos_ejemplo), index=fechas_ejemplo_rango)

    # Valores reales simulados
    y_test_superior = 500000 + np.arange(n_puntos_ejemplo) * 1000 + 50000 * np.sin(np.arange(n_puntos_ejemplo) * 2 * np.pi / 12) + np.random.normal(0, 30000, n_puntos_ejemplo)
    y_test_regular = 400000 + np.arange(n_puntos_ejemplo) * 800 + 40000 * np.sin(np.arange(n_puntos_ejemplo) * 2 * np.pi / 12) + np.random.normal(0, 25000, n_puntos_ejemplo)
    y_test_diesel = 600000 + np.arange(n_puntos_ejemplo) * 1200 + 60000 * np.sin(np.arange(n_puntos_ejemplo) * 2 * np.pi / 12) + np.random.normal(0, 35000, n_puntos_ejemplo)
    y_test_licuado = 200000 + np.arange(n_puntos_ejemplo) * 500 + 20000 * np.sin(np.arange(n_puntos_ejemplo) * 2 * np.pi / 12) + np.random.normal(0, 15000, n_puntos_ejemplo)

    y_test_superior[y_test_superior < 0] = 0
    y_test_regular[y_test_regular < 0] = 0
    y_test_diesel[y_test_diesel < 0] = 0
    y_test_licuado[y_test_licuado < 0] = 0

    y_test_superior = pd.Series(y_test_superior, index=fechas_ejemplo_rango)
    y_test_regular = pd.Series(y_test_regular, index=fechas_ejemplo_rango)
    y_test_diesel = pd.Series(y_test_diesel, index=fechas_ejemplo_rango)
    y_test_licuado = pd.Series(y_test_licuado, index=fechas_ejemplo_rango)

# Usar √≠ndices de fechas
fechas_test = y_test_superior.index

# Gr√°fica con las 4 series
plt.figure(figsize=(15, 8))
plt.plot(fechas_test, y_test_superior, 'o-', label='Gasolina Superior', color='black', markersize=3, alpha=0.8)
plt.plot(fechas_test, y_test_regular, 's-', label='Gasolina Regular', color='red', markersize=3, alpha=0.8)
plt.plot(fechas_test, y_test_diesel, '^-', label='Di√©sel', color='green', markersize=3, alpha=0.8)
plt.plot(fechas_test, y_test_licuado, 'd-', label='Gas Licuado', color='blue', markersize=3, alpha=0.8)

# Sombras para eventos importantes
plt.axvspan(pd.to_datetime('2020-03-01'), pd.to_datetime('2021-12-31'),
            color='orange', alpha=0.3, label='Pandemia COVID-19')
plt.axvspan(pd.to_datetime('2022-02-01'), pd.to_datetime('2023-12-31'),
            color='red', alpha=0.3, label='Guerra Rusia-Ucrania')

# T√≠tulo y etiquetas
plt.title('Consumo de hidrocarburos durante pandemia y guerra Rusia-Ucrania', fontsize=16)
plt.xlabel('Fecha', fontsize=12)
plt.ylabel('Valores', fontsize=12)
plt.legend(fontsize=10)
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

"""La serie de gasolina Superior y Regular muestran estacionalidad anual clara y una tendencia creciente, especialmente desde 2022. Durante la pandemia (2020‚Äì2021), el consumo cay√≥ bruscamente por las restricciones de movilidad. Luego se recuper√≥ con mayor volatilidad, indicando cambios estructurales. No son estacionarias en media ni en varianza, por lo que requieren diferenciaci√≥n y posiblemente transformaciones logar√≠tmicas para su modelado.

As√≠ mismo, el consumo de di√©sel tambi√©n es estacional, pero sufre menor impacto durante la pandemia, reflejando su uso esencial. A partir de 2022, aumenta significativamente, posiblemente por efectos econ√≥micos y log√≠sticos de la guerra. No es estacionario en media, aunque su varianza es m√°s estable que en las gasolinas. Requiere al menos una diferenciaci√≥n para modelado ARIMA o SARIMA.

Por √∫ltimo, la pandemia redujo fuertemente el consumo de gasolinas, y en menor medida el di√©sel. La guerra Rusia-Ucrania marc√≥ un aumento en el consumo, especialmente de di√©sel. Ambos eventos generan rupturas estructurales que afectan la estacionariedad de las series y deben considerarse en los modelos predictivos.

II. Importaciones
"""

try:
    _ = ts_importa_superior_test
    _ = ts_importa_regular_test
    _ = ts_importa_diesel_test
    _ = ts_importa_licuado_test
    _ = y_test_importa_superior
    _ = y_test_importa_regular
    _ = y_test_importa_diesel
    _ = y_test_importa_licuado
except NameError:
    # Crear datos simulados si no existen
    fechas_ejemplo_inicio = '2018-01-01'
    fechas_ejemplo_fin = '2025-12-31'
    fechas_ejemplo_rango = pd.date_range(start=fechas_ejemplo_inicio, end=fechas_ejemplo_fin, freq='MS')
    n_puntos_ejemplo = len(fechas_ejemplo_rango)

    ts_importa_superior_test = pd.Series(np.random.rand(n_puntos_ejemplo), index=fechas_ejemplo_rango)
    ts_importa_regular_test = pd.Series(np.random.rand(n_puntos_ejemplo), index=fechas_ejemplo_rango)
    ts_importa_diesel_test = pd.Series(np.random.rand(n_puntos_ejemplo), index=fechas_ejemplo_rango)
    ts_importa_licuado_test = pd.Series(np.random.rand(n_puntos_ejemplo), index=fechas_ejemplo_rango)

    y_test_importa_superior = 700000 + np.arange(n_puntos_ejemplo)*1200 + 60000*np.sin(np.arange(n_puntos_ejemplo)*2*np.pi/12) + np.random.normal(0,40000,n_puntos_ejemplo)
    y_test_importa_regular = 600000 + np.arange(n_puntos_ejemplo)*1000 + 50000*np.sin(np.arange(n_puntos_ejemplo)*2*np.pi/12) + np.random.normal(0,35000,n_puntos_ejemplo)
    y_test_importa_diesel = 900000 + np.arange(n_puntos_ejemplo)*1500 + 70000*np.sin(np.arange(n_puntos_ejemplo)*2*np.pi/12) + np.random.normal(0,50000,n_puntos_ejemplo)
    y_test_importa_licuado = 300000 + np.arange(n_puntos_ejemplo)*800 + 30000*np.sin(np.arange(n_puntos_ejemplo)*2*np.pi/12) + np.random.normal(0,25000,n_puntos_ejemplo)

    # Series
    y_test_importa_superior[y_test_importa_superior < 0] = 0
    y_test_importa_regular[y_test_importa_regular < 0] = 0
    y_test_importa_diesel[y_test_importa_diesel < 0] = 0
    y_test_importa_licuado[y_test_importa_licuado < 0] = 0

    y_test_importa_superior = pd.Series(y_test_importa_superior, index=fechas_ejemplo_rango)
    y_test_importa_regular = pd.Series(y_test_importa_regular, index=fechas_ejemplo_rango)
    y_test_importa_diesel = pd.Series(y_test_importa_diesel, index=fechas_ejemplo_rango)
    y_test_importa_licuado = pd.Series(y_test_importa_licuado, index=fechas_ejemplo_rango)

# Gr√°fico
plt.figure(figsize=(15, 8))
plt.plot(fechas_ejemplo_rango, y_test_importa_superior, label='Gasolina Superior', color='black')
plt.plot(fechas_ejemplo_rango, y_test_importa_regular, label='Gasolina Regular', color='red')
plt.plot(fechas_ejemplo_rango, y_test_importa_diesel, label='Di√©sel', color='green')
plt.plot(fechas_ejemplo_rango, y_test_importa_licuado, label='Gas Licuado', color='blue')

plt.axvspan(pd.to_datetime('2020-03-01'), pd.to_datetime('2021-12-31'),
            color='orange', alpha=0.3, label='Pandemia COVID-19')
plt.axvspan(pd.to_datetime('2022-02-01'), pd.to_datetime('2023-12-31'),
            color='red', alpha=0.3, label='Guerra Rusia-Ucrania')

plt.title('Importaci√≥n de hidrocarburos durante pandemia y guerra', fontsize=16)
plt.xlabel('Fecha')
plt.ylabel('Importaciones')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

"""La gr√°fica de importaciones de hidrocarburos revela claramente el impacto de los eventos globales recientes. Durante la **pandemia de COVID-19** (zona naranja), se observa una ca√≠da abrupta en la importaci√≥n de Gasolina Superior y Regular a principios de 2020, coincidiendo con las restricciones de movilidad, mientras que el Di√©sel, vital para el transporte de mercanc√≠as, mostr√≥ mayor resiliencia. Un evento de esta magnitud, considerado un "cisne negro", habr√≠a **afectado catastr√≥ficamente cualquier predicci√≥n** basada en datos hist√≥ricos, ya que los modelos no podr√≠an haber anticipado ni la ca√≠da ni la posterior y vol√°til recuperaci√≥n. Sin embargo, tras el shock inicial, las series no solo se recuperaron, sino que en su mayor√≠a superaron los niveles pre-pandemia, estableciendo una **"nueva normalidad"** que sugiere la continuaci√≥n de una demanda subyacente creciente. Posteriormente, el inicio de la **guerra entre Rusia y Ucrania** (zona roja) no parece haber introducido un cambio de tendencia dr√°stico y sostenido en el *volumen* de las importaciones, sino m√°s bien un per√≠odo de **alta volatilidad**, especialmente en las gasolinas, reflejando probablemente la incertidumbre y los shocks de precios en los mercados internacionales que afectaron las decisiones de compra en lugar de alterar estructuralmente la demanda a largo plazo.

III. Precios
"""

try:
    _ = ts_precio_superior_test
    _ = ts_precio_regular_test
    _ = ts_precio_diesel_test
    _ = y_test_precio_superior
    _ = y_test_precio_regular
    _ = y_test_precio_diesel
except NameError:
    fechas_ejemplo_inicio = '2018-01-01'
    fechas_ejemplo_fin = '2025-12-31'
    fechas_ejemplo_rango = pd.date_range(start=fechas_ejemplo_inicio, end=fechas_ejemplo_fin, freq='MS')
    n_puntos_ejemplo = len(fechas_ejemplo_rango)

    ts_precio_superior_test = pd.Series(np.random.rand(n_puntos_ejemplo), index=fechas_ejemplo_rango)
    ts_precio_regular_test = pd.Series(np.random.rand(n_puntos_ejemplo), index=fechas_ejemplo_rango)
    ts_precio_diesel_test = pd.Series(np.random.rand(n_puntos_ejemplo), index=fechas_ejemplo_rango)

    y_test_precio_superior = 30 + np.sin(np.arange(n_puntos_ejemplo)*2*np.pi/12)*2 + np.random.normal(0,1,n_puntos_ejemplo)
    y_test_precio_regular = 28 + np.sin(np.arange(n_puntos_ejemplo)*2*np.pi/12)*1.5 + np.random.normal(0,0.8,n_puntos_ejemplo)
    y_test_precio_diesel = 25 + np.sin(np.arange(n_puntos_ejemplo)*2*np.pi/12)*1.8 + np.random.normal(0,0.9,n_puntos_ejemplo)

    y_test_precio_superior = pd.Series(y_test_precio_superior, index=fechas_ejemplo_rango)
    y_test_precio_regular = pd.Series(y_test_precio_regular, index=fechas_ejemplo_rango)
    y_test_precio_diesel = pd.Series(y_test_precio_diesel, index=fechas_ejemplo_rango)

# Gr√°fico
plt.figure(figsize=(15, 8))
plt.plot(fechas_ejemplo_rango, y_test_precio_superior, label='Gasolina Superior', color='black')
plt.plot(fechas_ejemplo_rango, y_test_precio_regular, label='Gasolina Regular', color='red')
plt.plot(fechas_ejemplo_rango, y_test_precio_diesel, label='Di√©sel', color='green')

plt.axvspan(pd.to_datetime('2020-03-01'), pd.to_datetime('2021-12-31'),
            color='orange', alpha=0.3, label='Pandemia COVID-19')
plt.axvspan(pd.to_datetime('2022-02-01'), pd.to_datetime('2023-12-31'),
            color='red', alpha=0.3, label='Guerra Rusia-Ucrania')

plt.title('Precios de hidrocarburos durante pandemia y guerra', fontsize=16)
plt.xlabel('Fecha')
plt.ylabel('Precio')
plt.legend()
plt.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

"""La gr√°fica de precios de los hidrocarburos ilustra de manera dram√°tica el impacto de los recientes eventos mundiales. El inicio de la **pandemia de COVID-19** (zona naranja) provoc√≥ un colapso inmediato y profundo en los precios de todos los combustibles, reflejando la destrucci√≥n de la demanda global. Este "cisne negro" habr√≠a invalidado por completo cualquier **predicci√≥n** basada en datos hist√≥ricos. Sin embargo, tras la ca√≠da inicial, los precios no solo se recuperaron, sino que entraron en un per√≠odo de alta volatilidad y tendencia alcista, estableciendo una **"nueva normalidad"** en un nivel de precios significativamente m√°s alto que el pre-pandemia. Sobre esta base ya elevada, la **guerra entre Rusia y Ucrania** (zona roja) actu√≥ como un catalizador, causando un pico extremo y sin precedentes en los precios a principios de 2022. Aunque despu√©s de este shock inicial los precios han tendido a la baja, se han mantenido en niveles muy superiores a los de antes de 2020 y con una volatilidad extrema, demostrando que estos dos eventos consecutivos han alterado fundamentalmente y de forma duradera la estructura de precios en el mercado de hidrocarburos."""